<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Yui Lu | Yui Lu</title><meta name="author" content="Yui Lu"><meta name="copyright" content="Yui Lu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="GAMES101-现代计算机图形学入门一、引入 计算机图形学下关于“实时”的定义：&gt;30fps，&lt;30fps称为离线 计算机视觉与计算机图形学的区别：  二、线代基础基础运算叉乘基本运算：$$\vec{a}\times\vec{b}&#x3D;-\vec{b}\times\vec{a}\\vec{a}\times\vec{a}&#x3D;\vec{0}\\vec{a}\times(\v">
<meta property="og:type" content="website">
<meta property="og:title" content="Yui Lu">
<meta property="og:url" content="https://yuilu.github.io/notes/GAMES101%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E5%BC%95%E5%85%A5.html">
<meta property="og:site_name" content="Yui Lu">
<meta property="og:description" content="GAMES101-现代计算机图形学入门一、引入 计算机图形学下关于“实时”的定义：&gt;30fps，&lt;30fps称为离线 计算机视觉与计算机图形学的区别：  二、线代基础基础运算叉乘基本运算：$$\vec{a}\times\vec{b}&#x3D;-\vec{b}\times\vec{a}\\vec{a}\times\vec{a}&#x3D;\vec{0}\\vec{a}\times(\v">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.aqcoder.cn/random">
<meta property="article:published_time" content="2024-01-02T15:11:00.149Z">
<meta property="article:modified_time" content="2024-01-02T13:06:24.900Z">
<meta property="article:author" content="Yui Lu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.aqcoder.cn/random"><link rel="shortcut icon" href="/img/favicon-32x32-Arlecchino.png"><link rel="canonical" href="https://yuilu.github.io/notes/GAMES101%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E5%BC%95%E5%85%A5.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":730,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Yui Lu',
  isPost: false,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-01-02 21:06:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/bocchi.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/notes/"><i class="fa-fw fas fa-edit"></i><span> Note</span></a></li><li><a class="site-page child" href="/blogs/"><i class="fa-fw fas fa-file-alt"></i><span> Blog</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> Life</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/travel/"><i class="fa-fw fas fa-plane-departure"></i><span> Travel</span></a></li><li><a class="site-page child" href="/animes/"><i class="fa-fw fas fa-mug-hot"></i><span> ACGN</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user"></i><span> About</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about_cn/"><span> 简体中文</span></a></li><li><a class="site-page child" href="/about_en/"><span> English</span></a></li></ul></div></div></div></div><div class="page" id="body-wrap"><header class="not-home-page" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Yui Lu"><span class="site-name">Yui Lu</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/notes/"><i class="fa-fw fas fa-edit"></i><span> Note</span></a></li><li><a class="site-page child" href="/blogs/"><i class="fa-fw fas fa-file-alt"></i><span> Blog</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> Life</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/travel/"><i class="fa-fw fas fa-plane-departure"></i><span> Travel</span></a></li><li><a class="site-page child" href="/animes/"><i class="fa-fw fas fa-mug-hot"></i><span> ACGN</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user"></i><span> About</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about_cn/"><span> 简体中文</span></a></li><li><a class="site-page child" href="/about_en/"><span> English</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="page-site-info"><h1 id="site-title">Yui Lu</h1></div></header><main class="layout" id="content-inner"><div id="page"><div id="article-container"><h1 id="GAMES101-现代计算机图形学入门"><a href="#GAMES101-现代计算机图形学入门" class="headerlink" title="GAMES101-现代计算机图形学入门"></a><strong>GAMES101</strong>-现代计算机图形学入门</h1><h2 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h2><p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\光栅化.png" alt="光栅化"></p>
<p>计算机图形学下关于“实时”的定义：&gt;30fps，&lt;30fps称为离线</p>
<p><strong>计算机视觉与计算机图形学的区别：</strong></p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\计算机视觉与计算机图形学的区别.png" alt="计算机视觉与计算机图形学的区别"></p>
<h2 id="二、线代基础"><a href="#二、线代基础" class="headerlink" title="二、线代基础"></a>二、线代基础</h2><h3 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h3><h4 id="叉乘基本运算："><a href="#叉乘基本运算：" class="headerlink" title="叉乘基本运算："></a>叉乘基本运算：</h4><p>$$<br>\vec{a}\times\vec{b}&#x3D;-\vec{b}\times\vec{a}\<br>\vec{a}\times\vec{a}&#x3D;\vec{0}\<br>\vec{a}\times(\vec{b}+\vec{c})&#x3D;\vec{a}\times\vec{b}+\vec{a}\times\vec{c}\<br>\vec{a}\times(k\vec{b})&#x3D;k(\vec{a}\times\vec{b})<br>$$</p>
<p>图形学叉乘应用：判断左&#x2F;右&amp;内&#x2F;外</p>
<h4 id="正交坐标系定义"><a href="#正交坐标系定义" class="headerlink" title="正交坐标系定义"></a>正交坐标系定义</h4><p>$$<br>||\vec{u}||&#x3D;||\vec{v}||&#x3D;||\vec{w}||\<br>\vec{u}\cdot\vec{v}&#x3D;\vec{v}\cdot\vec{w}&#x3D;\vec{w}\cdot\vec{u}\<br>\vec{w}&#x3D;\vec{u}\times\vec{v}（右手）\\<br>\vec{p}&#x3D;(\vec{p}\cdot\vec{u})\vec{u}+(\vec{p}\cdot\vec{v})\vec{v}+(\vec{p}\cdot\vec{w})\vec{w}<br>$$</p>
<h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><p>要第几行第几列，就去找第几行和第几列，左管行，右管列</p>
<p>设矩阵A和矩阵B，则：</p>
<p>1、AB和BA大多数情况下不等</p>
<p>2、(AB)C&#x3D;A(BC)</p>
<p>​	  A(B+C) &#x3D; AB +AC</p>
<p>​	  (A+B)C &#x3D;AC ＋BC		&#x2F;&#x2F;只要不涉及前后交换</p>
<h4 id="矩阵和向量的乘法"><a href="#矩阵和向量的乘法" class="headerlink" title="矩阵和向量的乘法"></a>矩阵和向量的乘法</h4><p>总是把向量视作列向量并置于乘号右边</p>
<h4 id="矩阵转置（ij-ji）"><a href="#矩阵转置（ij-ji）" class="headerlink" title="矩阵转置（ij -&gt; ji）"></a>矩阵转置（ij -&gt; ji）</h4><p>$$<br>(AB)^T&#x3D;B^TA^T<br>$$</p>
<h4 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h4><p>$$<br>AA^{-1}&#x3D;A^{-1}A&#x3D;I\<br>AB^{-1}&#x3D;B^{-1}A^{-1}<br>$$</p>
<h4 id="向量乘法的矩阵形式"><a href="#向量乘法的矩阵形式" class="headerlink" title="向量乘法的矩阵形式"></a>向量乘法的矩阵形式</h4><p>$$<br>\vec{a}\cdot\vec{b}&#x3D;\vec{a}^T\vec{b}\<br>\vec{a}\times\vec{b}&#x3D;A^*b<br>$$</p>
<h3 id="向量变换"><a href="#向量变换" class="headerlink" title="向量变换"></a>向量变换</h3><h4 id="2d"><a href="#2d" class="headerlink" title="2d"></a>2d</h4><h5 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h5><table>
<thead>
<tr>
<th align="center">缩放</th>
<th align="center">切变</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p3-变化\线性变化-缩放.png" alt="线性变化-缩放"></td>
<td align="center"><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p3-变化\线性变化-切变.png" alt="线性变化-切变"></td>
</tr>
<tr>
<td align="center"><strong>对称</strong></td>
<td align="center"><strong>旋转</strong></td>
</tr>
<tr>
<td align="center"><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p3-变化\线性变化-对称.png" alt="线性变化-对称"></td>
<td align="center"><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p3-变化\线性变化-旋转.png" alt="线性变化-旋转"></td>
</tr>
</tbody></table>
<p>相同维度线性变化：<br>$$<br>x’&#x3D;ax+by\y’&#x3D;cx+dy\<br>\left[\begin{matrix}x’\y’\\end{matrix}\right]&#x3D;<br>\left[\begin{matrix}a&amp;b\c&amp;d\\end{matrix}\right]<br>\left[\begin{matrix}x\y\\end{matrix}\right]\<br>x’&#x3D;Mx<br>$$</p>
<h5 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h5><p>点(x,y,1)	向量(x,y,0)	则有：</p>
<p>点-点&#x3D;向量，向量$\pm$向量&#x3D;向量，点+向量&#x3D;点，点+点&#x3D;两点的中点</p>
<p>在齐次坐标中，$\left(\begin{matrix}x\y\w\end{matrix}\right)$都视作$\left(\begin{matrix}x&#x2F;w\y&#x2F;w\1\end{matrix}\right)$，其中$w≠0$</p>
<h5 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h5><p>&#x3D;&#x3D;仿射变化&#x3D;线性变换+平移&#x3D;&#x3D;</p>
<table>
<thead>
<tr>
<th><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p3-变化\仿射变化.png" alt="仿射变化"></th>
<th>![仿射变化-2d transformation](F:-STUDY-\college\闫令琪_图形学入门\101\图片\p3-变化\仿射变化-2d transformation.png)</th>
</tr>
</thead>
</table>
<p>&#x3D;&#x3D;矩阵相乘不满足结合律&#x3D;&#x3D;</p>
<p>例如，先旋转再平移和先平移再旋转所得结果不一样</p>
<h5 id="变换合成（结合律的体现）"><a href="#变换合成（结合律的体现）" class="headerlink" title="变换合成（结合律的体现）"></a>变换合成（结合律的体现）</h5><p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p3-变化\合成变换.png" alt="合成变换"></p>
<h4 id="3d"><a href="#3d" class="headerlink" title="3d"></a>3d</h4><table>
<thead>
<tr>
<th align="center">平移</th>
<th align="center">缩放</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p4-3d变化，观测视图\平移.png" alt="平移"></td>
<td align="center"><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p4-3d变化，观测视图\缩放.png" alt="缩放"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>旋转</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p4-3d变化，观测视图\旋转1.png" alt="旋转1"></td>
<td><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p4-3d变化，观测视图\旋转2.png" alt="旋转2"></td>
</tr>
</tbody></table>
<p>3d旋转变换矩阵遵循循环对称：$X\times Y&#x3D;Z,Y\times Z&#x3D;X,Z\times X&#x3D;Y$</p>
<p>合成的旋转变换：$R_{xyz}(\alpha,\beta,\gamma)&#x3D;R_x(\alpha)R_y(\beta)R_z(\gamma)$</p>
<h5 id="罗德里格斯旋转公式"><a href="#罗德里格斯旋转公式" class="headerlink" title="罗德里格斯旋转公式"></a>罗德里格斯旋转公式</h5><p>绕旋转轴n旋转α角度<br>$$<br>R(n,\alpha)&#x3D;cos(\alpha)E+(1-cos(\alpha))nn^T+sin(\alpha)<br>\left(\begin{matrix}<br>0	 &amp; -n_z	&amp; n_y	\<br>n_z	 &amp; 0	&amp; -n_x	\<br>-n_y &amp; n_x	&amp; 0		\<br>\end{matrix}\right)<br>$$<br>推导过程：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113299607?utm_source=qq&utm_medium=social&utm_oi=605668290971045888">https://zhuanlan.zhihu.com/p/113299607?utm_source=qq&amp;utm_medium=social&amp;utm_oi=605668290971045888</a></p>
<p><strong>四元数：旋转与旋转之间的差值，具体内容略去</strong></p>
<h3 id="视图-相机变换"><a href="#视图-相机变换" class="headerlink" title="视图 &#x2F; 相机变换"></a>视图 &#x2F; 相机变换</h3><h4 id="如何将三维变成二维并在屏幕上显示出来"><a href="#如何将三维变成二维并在屏幕上显示出来" class="headerlink" title="如何将三维变成二维并在屏幕上显示出来"></a>如何将三维变成二维并在屏幕上显示出来</h4><p>1、模型变换 (M)		2、相机变换 (V)		3、投影变换 (P)</p>
<h4 id="定义相机属性"><a href="#定义相机属性" class="headerlink" title="定义相机属性"></a>定义相机属性</h4><p>1、位置 $\vec{e}$</p>
<p>2、视线方向 $\widehat{g}$</p>
<p>3、垂直方向 $\widehat{t}$</p>
<p>初始：up at Y, look at -Z</p>
<p>如果把摄像机和世界一起变换，那么照片是一样的，所以把摄像机变换到新坐标系的原点，其他所有物体也做同样的变换</p>
<h4 id="teg坐标系怎么转变为xyz坐标系"><a href="#teg坐标系怎么转变为xyz坐标系" class="headerlink" title="teg坐标系怎么转变为xyz坐标系"></a>teg坐标系怎么转变为xyz坐标系</h4><p>$M_{view}$ in Math?</p>
<p>$M_{view}$&#x3D;$R_{view}$$T_{view}$</p>
<p>1、先做平移，$T_{view}&#x3D;\left[\begin{matrix}1&amp;0&amp;0&amp;-x_e\0&amp;1&amp;0&amp;-y_e\0&amp;0&amp;1&amp;-z_e\0&amp;0&amp;0&amp;1\end{matrix}\right]$</p>
<p>2、再做旋转，顺着思路要把 $\widehat{g}$ 旋转到$-Z$坐标轴，把 $\widehat{t}$ 旋转到$Y$坐标轴，把$（g\times t）$旋转到 $x$ 坐标轴，但这样的旋转矩阵非常难写</p>
<p>​	  所以采用逆向思路，把坐标轴移到相机坐标轴，通过逆操作写（该旋转矩阵为正交矩阵，其逆矩阵就是它的转置矩阵）（基变换）<br>$$<br>R^{-1}<em>{view}&#x3D;<br>\left[\begin{matrix}<br>x</em>{\widehat g\times \widehat t} &amp; x_t &amp; x_{-g} &amp; 0\<br>y_{\widehat g\times \widehat t} &amp; y_t &amp; y_{-g} &amp; 0\<br>z_{\widehat g\times \widehat t} &amp; z_t &amp; z_{-g} &amp; 0\<br>0 &amp; 0 &amp; 0 &amp; 1\<br>\end{matrix}\right]\</p>
<p>R_{view}&#x3D;\left[\begin{matrix}<br>x_{\widehat g\times \widehat t} &amp; y_{\widehat g\times \widehat t} &amp; z_{\widehat g\times \widehat t} &amp; 0\<br>x_t &amp; y_t &amp; z_t &amp; 0\<br>x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0\<br>0 &amp; 0 &amp; 0 &amp; 1\<br>\end{matrix}\right]<br>$$</p>
<h3 id="投影变换（难点）"><a href="#投影变换（难点）" class="headerlink" title="投影变换（难点）"></a>投影变换（难点）</h3><p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p4-3d变化，观测视图\正交or透视.png" alt="正交or透视"></p>
<h4 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h4><p>相机位置无限远，没有远近概念（忽略深度信息）</p>
<p>步骤：先做平移，再做缩放，目标是吧投影全塞在 $[-1,1]^2$ 的长方体内</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p4-3d变化，观测视图\正交投影步骤.png" alt="正交投影步骤"></p>
<h4 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h4><p>用的最广泛的投影，近大远小，</p>
<p>根据已知的$Near、Far、Fov、Aspect$确定透视投影的投影矩阵，如下<br>$$<br>M_{frustum}&#x3D;<br>\left[\begin{matrix}<br>\frac{cot\frac{FOV}{2}}{Aspect}	&amp;	0	&amp;	0	&amp;	0\<br>0	&amp;	cot{\frac{FOV}{2}}	&amp;	0	&amp;	0\<br>0	&amp;	0	&amp;	\frac{Near+Far}{Near-Far}	&amp;	-\frac{2Near·Far}{Near-Far}\<br>0	&amp;	0	&amp;	1	&amp;	0\<br>\end{matrix}\right]\<br>$$<br>具体证明见《unity shader入门精要》P79手写笔记</p>
<p>关于课上的思考问题，视锥体压缩成长方体以后，内部的点的z值是更偏向于近平面还是更偏向于远平面？</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/122411512?utm_source=qq&utm_medium=social&utm_oi=605668290971045888">https://zhuanlan.zhihu.com/p/122411512?utm_source=qq&amp;utm_medium=social&amp;utm_oi=605668290971045888</a></p>
<h2 id="三、三角形的光栅化"><a href="#三、三角形的光栅化" class="headerlink" title="三、三角形的光栅化"></a>三、三角形的光栅化</h2><p>屏幕是一个二维数组的标准数据集，是离散的，是一个典型的光栅成像设备</p>
<h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>光栅化即把图像呈现在屏幕上的过程</p>
<p><strong>像素</strong>是“最小的”图像单元，一个像素内的颜色，由r，g，b三个参数控制</p>
<p>由裁剪空间映射到屏幕空间（视口变换）公式如下：<br>$$<br>M_{viewport}&#x3D;<br>\left[\begin{matrix}<br>\frac{width}{2}	&amp;	0	&amp;	0	&amp;	\frac{width}{2}\<br>0	&amp;	\frac{height}{2}	&amp;	0	&amp;	\frac{height}{2}\<br>0	&amp;	0	&amp;	1	&amp;	0\<br>0	&amp;	0	&amp;	0	&amp;	1\<br>\end{matrix}\right]\<br>$$<br>经过矩阵变换后，再把屏幕空间中的多边形打散成三角形，成像到屏幕上，这就是光栅化的大致流程</p>
<p>计算机生成图像中，最基本的二维元素是三角形</p>
<p>三角形的特质：① 保证是平面；内外定义清晰；	② 具有成熟的顶点插值方法</p>
<h3 id="不同的光栅化设备"><a href="#不同的光栅化设备" class="headerlink" title="*不同的光栅化设备"></a>*不同的光栅化设备</h3><p><strong>示波器oscilloscope</strong></p>
<p><strong>CRT屏幕：</strong></p>
<p>早期成像原理：阴极射线管</p>
<p>早期电视：光栅化的CRT屏幕，隔行扫描技术</p>
<p><strong>当今成像设备：平板显示设备</strong></p>
<p><strong>LCD液晶显示器：</strong>液晶会通过自己的不同排布，影响光的极化</p>
<p><strong>LED显示器：</strong>发光二极管点阵列</p>
<p><strong>电子水墨屏：</strong>电泳成像，刷新频率低</p>
<p><strong>OLED显示器：</strong>有机发光半导体</p>
<h3 id="最简单的光栅化方法：采样"><a href="#最简单的光栅化方法：采样" class="headerlink" title="最简单的光栅化方法：采样"></a>最简单的光栅化方法：采样</h3><p>采样，就是把函数离散化的一个过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; imax; i++)</span><br><span class="line">	output[i] = f(i);</span><br></pre></td></tr></table></figure>

<p>为判断该为哪块像素着色，我们定义一个二进制函数：inside(tri,x,y)<br>$$<br>inside(tri,x,y)&#x3D;<br>\left{\begin {array}{rcl}<br>1&amp;point(x,y)\ in\ △t\<br>2&amp;otherwise<br>\end {array}\right.<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; imax; i++)&#123;</span><br><span class="line">	for(int j = 0; j &lt; jmax; j++)&#123;</span><br><span class="line">		image[i][j] = inside(tri, i+0.5, j+0.5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="采样优化"><a href="#采样优化" class="headerlink" title="采样优化"></a>采样优化</h3><p>Axis-Aligned Bounding Box：包围盒</p>
<p>在光栅化前先行判断像素点是否在三角形所在包围盒内，若不在，则直接忽略，不进光栅化的循环判断</p>
<p>Incremental Triangle Traversal：增量三角形遍历</p>
<p>看似更快，实则实现起来有一定难度，适用于细长的三角形</p>
<p>采样率不够高 -&gt; 锯齿，走样</p>
<h3 id="抗锯齿与深度缓冲"><a href="#抗锯齿与深度缓冲" class="headerlink" title="抗锯齿与深度缓冲"></a>抗锯齿与深度缓冲</h3><h4 id="采样伪影"><a href="#采样伪影" class="headerlink" title="采样伪影"></a>采样伪影</h4><p>锯齿（空间采样上的错误）</p>
<p>摩尔纹（如，采样时跳过奇数行奇数列）</p>
<p>马车轮效应：人眼在时间上的采样跟不上运动速度</p>
<p>采样伪影的原因：信号频率太快，采样速度跟不上</p>
<h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h4><p>傅里叶级数展开：任何一个周期函数，都可以表示为一系列sin和cos函数的线性组合加一个常数项的形式</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p6-抗锯齿\傅里叶级数变换.png" alt="傅里叶级数变换"></p>
<p>傅里叶变换，与傅里叶级数展开关系并不大，可以把图像从时域（空间域）变换到频域</p>
<p><em>用信号处理解释走样：同样一种采样方法，采样两种不同频率的函数，得出的结果无法被区分</em></p>
<h5 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h5><p>在频域内去除某一特定频率的函数</p>
<p>高通滤波器，低通滤波器，具体处理过程：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/365546998?utm_source=qq&utm_medium=social&utm_oi=605668290971045888">https://zhuanlan.zhihu.com/p/365546998?utm_source=qq&amp;utm_medium=social&amp;utm_oi=605668290971045888</a></p>
<p>滤波&#x3D;平均&#x3D;卷积</p>
<p>卷积核越大，保留的高频信息越少，低频信息越多，对应到频域图上，高频区域的亮度就降低</p>
<h4 id="走样的本质"><a href="#走样的本质" class="headerlink" title="走样的本质"></a>走样的本质</h4><table>
<thead>
<tr>
<th>采样的本质</th>
<th>走样的本质</th>
</tr>
</thead>
<tbody><tr>
<td><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p6-抗锯齿\采样的本质.png" alt="采样的本质"></td>
<td><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p6-抗锯齿\走样的本质.png" alt="走样的本质"></td>
</tr>
</tbody></table>
<p>采样率变低，采样间隔变大，波长变大，频率变小</p>
<p>Dense sampling&#x3D;&#x3D;稠密采样&#x3D;&#x3D;，图中信号已经首尾相接，意味着当前的采样频率Fs是不发生走样的最低限值</p>
<p>Sparse sampling&#x3D;&#x3D;稀疏采样&#x3D;&#x3D;，意味着频率Fs变大，间隔变小，就会产生混叠（近视也是因为这种混叠，可以类比一下）</p>
<p>所以，像素越低，采样率越低，采样频率越小，采样越稀疏，更容易走样</p>
<h4 id="反走样技术思路"><a href="#反走样技术思路" class="headerlink" title="反走样技术思路"></a>反走样技术思路</h4><p>1、增加屏幕分辨率，增加采样频率（成本高）</p>
<p>2、在采样之前，进行模糊（&#x2F;滤波）处理，<u>（注意，先模糊处理在采样，反过来是不可行的）</u>，模糊以后，将图像的边界弱化了，采样的时候，该区域对应的像素值可以起到过度缓冲的效果（低通滤波降低信号最高频率，使得可以用更低的采样频率完成采样）</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p6-抗锯齿\低通滤波反走样.png" alt="低通滤波反走样"></p>
<p>先采样后模糊之所以不可行，就是因为波形重叠的情况下截断依然会有重叠</p>
<p>通过像素做平均（卷积）来达到反走样：</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p6-抗锯齿\像素低通滤波.png" alt="像素低通滤波"></p>
<p>如何计算图形在某一像素内覆盖的比例？</p>
<p>一种近似方法：&#x3D;&#x3D;MSAA&#x3D;&#x3D;（muti-sample anti-aliasing）</p>
<p>每个像素多次采样，求平均，像素的颜色值为负责的区域内取样多次颜色值的平均</p>
<p>MSAA并没有通过物理上增加分辨率达到抗锯齿效果，这些网格只是为了检测覆盖率而已，并且现实应用并非用网格，而是用一些其他图形来达到效果，涉及一些随机数分布（怎样分布样本达到最好的覆盖效果）</p>
<p>那么，代价是什么？太浪费性能！		优化：采样复用</p>
<p>3、其他抗锯齿方案</p>
<ul>
<li>&#x3D;&#x3D;FXAA&#x3D;&#x3D; (Fast Approximate AA)：先获得有锯齿的图，再后处理去除锯齿（很快）<ul>
<li>找到边界，换成没有锯齿的边界，（图像匹配）非常快</li>
<li>方法和采样无关，采样虽然有误，但是这种方法可以弥补</li>
</ul>
</li>
<li>&#x3D;&#x3D;TAA&#x3D;&#x3D; (Tem‘poral AA) ：时序信息，借助前面帧的信息<ul>
<li>最近刚刚兴起</li>
<li>静态场景，相邻两帧同一像素用不同的位置来sample</li>
<li>把MSAA的Sampling分布在时间上</li>
<li>运动情况下怎么办？</li>
</ul>
</li>
</ul>
<p>Super resolution &#x2F; super sampling 超分辨率</p>
<p>低分辨率显示器还原高分辨率图片，归根结底依旧是”样本不足“，解决方案举例：DLSS (Deep Learning Super Sampling) </p>
<h4 id="深度缓存-Zbuffering"><a href="#深度缓存-Zbuffering" class="headerlink" title="深度缓存 -Zbuffering"></a>深度缓存 -Zbuffering</h4><p>Painter’s Algorithm：画家算法，由远及近画画，近处画面覆盖远处画面</p>
<p>无法处理复杂的深度判断，例如三个三角形互相重叠</p>
<p>深度计算排序 算法复杂度：$O(log\ n)$</p>
<p>&#x3D;&#x3D;Z-buffer：对每个像素多存一个深度&#x3D;&#x3D;</p>
<p>实际编程中，z值越小表示越远，但为方便理解，下述伪代码中z越远越大</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(each Triangle T)</span><br><span class="line">	for(each sample(x,y,z) in T)</span><br><span class="line">		if(z&lt;zbuffer[x,y])</span><br><span class="line">			framebuffer[x,y]=rgb;</span><br><span class="line">			zbuffer[x,y]=z;</span><br><span class="line">		else</span><br><span class="line">			;</span><br></pre></td></tr></table></figure>

<p>复杂度：O(n) for n triangles 并不是排序，而是求最值，需要保证三角形进入顺序和结果无关</p>
<p>tips：无法处理透明物体，详情参考《入门精要》第八章</p>
<h2 id="四、光照、着色、图形管线"><a href="#四、光照、着色、图形管线" class="headerlink" title="四、光照、着色、图形管线"></a>四、光照、着色、图形管线</h2><h3 id="Blinn-Phong光照模型"><a href="#Blinn-Phong光照模型" class="headerlink" title="Blinn-Phong光照模型"></a>Blinn-Phong光照模型</h3><h4 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h4><p>要知道物体表面多亮，就要知道从光源到物体表面发射的能量光是多少，单位的能量光在单位球上的能量表示为 I，同一个点上的能量随着光不断向外传播而逐渐减少， 根据能量守恒定律，每一个球面上的总能量都是相同的（这在之后辐射度量学会有补充）</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p8-shading\漫反射phone模型推导.png" alt="漫反射phone模型推导"></p>
<p>由此可以得到关系式：<br>$$<br>1^24πI&#x3D;r^24πI’<br>$$<br>再计算物体表面着色点反射多少能量光给摄像机接收</p>
<p>用一个系数$K_d$表示该着色点的光吸收率，范围是$[0,1]$，如果该系数是 0，证明该着色点完全吸收能量，反之，如果是 1，代表该点完全不吸收能量</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p8-shading\漫反射phone模型.png" alt="漫反射phone模型"></p>
<p>把这个系数看作是&#x3D;&#x3D;RGB颜色值&#x3D;&#x3D;，当$K_d&#x3D;0$时，此时对应着RGB值是：[0, 0, 0]，在计算机里表示为黑色，黑色正是完全吸收光的颜色，反之，当$K_d&#x3D;1$时，对应着 [255, 255, 255]，在计算机里表示为白色，白色正是完全反射光的颜色</p>
<p>最终公式为公式：<br>$$<br>L_d&#x3D;k_d(\frac{I}{r^2})max(0,n·l)<br>$$</p>
<h4 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h4><p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p8-shading\镜面反射phone模型.png" alt="镜面反射phone模型"></p>
<p> $h$ 为 $l$ 和 $v$ 的半程向量， $n$ 为法线向量， $v$ 为观测角度，</p>
<p>假设前提：观测向量 $v$ 与镜面反射向量 $R$ 的夹角 与  $n$ 和 $h$ 的夹角相等( $R$ 在图中未标明）</p>
<p>why：计算机计算 $v$ 与 $R$ 的角度非常麻烦，考虑到大量像素的性能开销，因此使用较简单的半程向量进行计算</p>
<table>
<thead>
<tr>
<th><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p8-shading\指数p的作用.png" alt="指数p的作用"></th>
<th><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p8-shading\对比图.png" alt="对比图"></th>
</tr>
</thead>
</table>
<p>左图：指数p是为了进一步缩小高光范围所提供的的参数，通常取值大于100</p>
<p>右图：不同光照强度和p的取值对高光效果的影响</p>
<h4 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h4><p>Blinn-Phone光照模型中，假设从四面八方反射而来的光的光强都是相等的，也就是说可以认为环境光强为一个常数（实际上全局光照的计算要复杂的多），公式为$L_a&#x3D;K_aI_a$</p>
<h4 id="叠加效果"><a href="#叠加效果" class="headerlink" title="叠加效果"></a>叠加效果</h4><p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p8-shading\三种光照的叠加效果.png" alt="三种光照的叠加效果"></p>
<h3 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h3><h4 id="Flat-Shading（平面着色）"><a href="#Flat-Shading（平面着色）" class="headerlink" title="Flat Shading（平面着色）"></a>Flat Shading（平面着色）</h4><p>以三角面为单位进行着色，对于光滑的几何体效果很差</p>
<h4 id="Gouraud-Shading（高洛德着色）"><a href="#Gouraud-Shading（高洛德着色）" class="headerlink" title="Gouraud Shading（高洛德着色）"></a>Gouraud Shading（高洛德着色）</h4><p>以顶点为单位进行着色，通过插值计算，实现点与点之间颜色的平滑过渡</p>
<h4 id="Phone-Shading（冯氏着色）"><a href="#Phone-Shading（冯氏着色）" class="headerlink" title="Phone Shading（冯氏着色）"></a>Phone Shading（冯氏着色）</h4><p>以片元为单位进行着色，对每个点计算一次光照，点的法向量是通过顶点法向量插值得到的，冯氏着色最接近现实，可以在减少三角面数的情况下达到相同的效果（插值后法向量会光滑变化），当然，性能开销也非常大</p>
<h3 id="图形管线（实时渲染管线）"><a href="#图形管线（实时渲染管线）" class="headerlink" title="图形管线（实时渲染管线）"></a>图形管线（实时渲染管线）</h3><p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p8-shading\图形管线.png" alt="图形管线"></p>
<p>顶点处理 -&gt; 三角形处理 -&gt; 光栅化 -&gt; 片元处理 -&gt; 逐片元操作</p>
<p>其中，Vertex和Fragment阶段是可编程的</p>
<p>由于翻译问题，具体可以参考《unity shader入门精要》p9 内容</p>
<p><strong>GPUs：</strong>可并行的图形管线处理器</p>
<p>当下的图形实时处理技术可以实时的处理200-400万面的复杂场景数据，并以30-60的帧率动态处理（VR的帧率会更加夸张）</p>
<h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><h4 id="Texture-Mapping-纹理映射"><a href="#Texture-Mapping-纹理映射" class="headerlink" title="Texture Mapping 纹理映射"></a>Texture Mapping 纹理映射</h4><p>想要在三维物体的不同表面生成不同的纹理，就需要将三维图形的表面映射至二维表面（展UV）</p>
<p>三维图形的每个三角面顶点都可以对应一个uv坐标系下的坐标，uv坐标范围约定在$[0,1]$之间</p>
<p>可复用纹理：纹理本身可以被设计为无缝衔接（tilable）,Wang-Tiling是其中一种方法</p>
<h4 id="重心坐标"><a href="#重心坐标" class="headerlink" title="重心坐标"></a>重心坐标</h4><p>注意和重心概念的区别！对于三角形所在平面上的任意一点的坐标，都可以用三角形的三个顶点坐标的线性表达式表示<br>$$<br>(x,y)&#x3D;\alpha A+\beta B+\gamma C<br>$$<br>则$(\alpha,\beta,\gamma)$被称为该点的重心坐标，定理：$\alpha+\beta+\gamma&#x3D;1$</p>
<p>对于三角形内的点，$\alpha,\beta,\gamma&gt;0$，更特殊的情况，三角形&#x3D;&#x3D;重心的重心坐标&#x3D;&#x3D;为$(\frac{1}{3},\frac{1}{3},\frac{1}{3})$</p>
<p>求$\alpha,\beta,\gamma$公式：<br>$$<br>\alpha &#x3D; \frac{-(x-x_B)(y_C-y_B)+(y-y_B)(x_C-x_B)}<br>              {-(x_A-x_B)(y_C-y_B)+(y_A-y_B)(x_C-x_B)}\<br>\beta &#x3D; \frac{-(x-x_C)(y_A-y_C)+(y-y_C)(x_A-x_C)}<br>              {-(x_B-x_C)(y_A-y_C)+(y_B-y_C)(x_A-x_C)}\<br>\gamma &#x3D; 1-\alpha -\beta<br>$$<br>推导：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wangjiangrong/article/details/115326930">https://blog.csdn.net/wangjiangrong/article/details/115326930</a></p>
<p>几何意义：$(x,y)$与三角形的三个顶点构成三个三角形，顶点&#x3D;&#x3D;所对&#x3D;&#x3D;的三角形的面积与三角形总面积的比值，即为对应的重心坐标值</p>
<p>利用重心坐标实现线性插值：</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p9-shading\重心坐标插值.png" alt="重心坐标插值"></p>
<p>注意，&#x3D;&#x3D;重心坐标在映射过程中并非保持不变&#x3D;&#x3D;，所以需要在对应时间计算对应的重心坐标来做插值，不能随意复用！</p>
<p>映射过程伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreach rasterized screen sample(x,y) //通常来说是一个像素的中心</span><br><span class="line">	(u,v) = evaluate texture coordinate at (x,y) //用重心坐标插值</span><br><span class="line">	texcolor = texture,sample(u,v);</span><br><span class="line">	set sample&#x27;s color to texture; //作为漫反射系数</span><br></pre></td></tr></table></figure>

<h4 id="纹理过小-or-纹理过大？"><a href="#纹理过小-or-纹理过大？" class="headerlink" title="纹理过小 or. 纹理过大？"></a>纹理过小 or. 纹理过大？</h4><h5 id="纹理太小"><a href="#纹理太小" class="headerlink" title="纹理太小"></a>纹理太小</h5><p>可以理解为多个pixel映射到了同一个texel</p>
<p>解决方案：</p>
<p>1、水平+竖直做两次插值，即&#x3D;&#x3D;双线性插值&#x3D;&#x3D; Lerp</p>
<p>2、对周围16个点做三次插值，&#x3D;&#x3D;双三次插值&#x3D;&#x3D; Bicubic，运算量更大，结果更好</p>
<h5 id="纹理太大"><a href="#纹理太大" class="headerlink" title="纹理太大"></a>纹理太大</h5><p>可以理解为一个pixel对应了多个纹素，因采样频率不足而导致摩尔纹+锯齿（走样）</p>
<p>解决方案：</p>
<p>Supersampling多重采样，性能开销过大，所以干脆舍弃超级采样的思路</p>
<p>&#x3D;&#x3D;Mipmap算法：&#x3D;&#x3D;</p>
<p>事先准备多张不同级别（D）的纹理贴图，每升一个级别，横纵纹素各减小一半，最后显存消耗仅为原来的$\frac{4}{3}$，如此分级之后，设屏幕空间下采样像素与相邻像素中心点之间的距离为L，在u-v坐标系找到这些像素的中心点对应的坐标，求出L在u-v坐标系下对应的纹素数量，做对数运算求得对应像素的纹理细节的级别，再以对应级别做&#x3D;&#x3D;双线性插值&#x3D;&#x3D;</p>
<p>由于这种方法中，D是整数，而并非连续的值，为了得到连续的效果，在做对数运算后对小数部分算一下权重，并取向下取整的D值与D+1两个级别，对着两个级别分别做一次双线性插值，最后对插值结果再进行一次插值，我们称这种方法为&#x3D;&#x3D;三线性插值&#x3D;&#x3D;</p>
<table>
<thead>
<tr>
<th><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p9-shading\求L.png" alt="求L"></th>
<th><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p9-shading\三线性插值.png" alt="三线性插值"></th>
</tr>
</thead>
</table>
<p><strong>MipMap算法的局限</strong>：只能在u-v坐标系下做方块查询，有时候会造成过度模糊的情况</p>
<p>为了避免这种情况，引入&#x3D;&#x3D;各向异性过滤&#x3D;&#x3D;，在准备不同级别的纹理贴图时，不再是简简单单横纵纹素各减小一半进行分级，而是长减半宽不变 or 宽减半长不变 or 长和宽各减半三种情况各进行一次分级，显存消耗为原来的三倍，但性能方面并没有多少影响，这种方法就可以实现在u-v坐标系下进行矩形查询。</p>
<p>比各向异性更进一步的过滤，如EWA filtering 椭圆取样，则利用多次查询求平均值的方法来处理不规则区域，相应的性能开销就会比较大了</p>
<p>由上可知，在显存足够的情况下，各向异性过滤级别开越高越好</p>
<p>这块内容显然特别抽象，具体细节可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144332091?utm_source=qq&utm_medium=social&utm_oi=605668290971045888">https://zhuanlan.zhihu.com/p/144332091?utm_source=qq&amp;utm_medium=social&amp;utm_oi=605668290971045888</a></p>
<h4 id="各种纹理贴图"><a href="#各种纹理贴图" class="headerlink" title="各种纹理贴图"></a>各种纹理贴图</h4><h5 id="环境光贴图"><a href="#环境光贴图" class="headerlink" title="环境光贴图"></a>环境光贴图</h5><p>假设光源无限远，只记录光照的方向信息，这种贴图被称作环境光贴图</p>
<p>e.g. Utah Teaport 犹他茶壶；Stanford Bunny 斯坦福兔子</p>
<ul>
<li><p>球面环境映射 Spherical Environment Map</p>
<p>球心为世界中心。类比地球仪展开铺平，存在纹理的拉升扭曲问题，解决方法：Cube Map</p>
</li>
<li><p>立方体贴图 Cube Map</p>
<p>将环境光照信息记录在一个立方体表面上，但会需要额外判断某一方向上的光照应该记录在立方体的哪个面上，计算量更大</p>
</li>
</ul>
<h5 id="凹凸贴图"><a href="#凹凸贴图" class="headerlink" title="凹凸贴图"></a>凹凸贴图</h5><p>记录了纹理的高度移动，并不改变原来模型的几何信息，通过法线扰动，得到模拟出来的着色效果，以假乱真</p>
<p><strong>计算法线的方法：</strong></p>
<table>
<thead>
<tr>
<th><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\计算法线方向1.png" alt="计算法线方向1"></th>
<th><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\计算法线方向2.png" alt="计算法线方向2"></th>
</tr>
</thead>
</table>
<p><strong>UV下的法线算法：</strong></p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\UV下的法线算法.png" alt="UV下的法线算法"></p>
<p>局部坐标下，$n&#x3D;(-\frac{dp}{du},-\frac{dp}{dv},1).normalized$</p>
<h5 id="置换贴图"><a href="#置换贴图" class="headerlink" title="置换贴图"></a>置换贴图</h5><p>与凹凸贴图类似，但置换贴图是真的改变了几何信息，去对模型的顶点做位移，会比凹凸贴图更加逼真，但对模型的精度（三角面数量）要求更高，并且运算量也会随之上升</p>
<p>DirectX有Dynamic的插值法，根据需要对模型做插值，看情况决定模型的细致程度</p>
<p>凹凸贴图vs.置换贴图：</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\凹凸贴图vs.位移贴图.png" alt="凹凸贴图vs.位移贴图"></p>
<h5 id="程序纹理"><a href="#程序纹理" class="headerlink" title="程序纹理"></a>程序纹理</h5><p>三维的纹理，并非真正生成了纹理的图，而是定义空间中任意点的颜色</p>
<p>定义三维空间中的噪声函数，再通过映射，得到预想的效果</p>
<h5 id="预计算着色"><a href="#预计算着色" class="headerlink" title="预计算着色"></a>预计算着色</h5><p>将环境光进行预计算处理，再附在原先纹理上做一层遮蔽，再将纹理贴到模型上</p>
<h5 id="三维渲染"><a href="#三维渲染" class="headerlink" title="三维渲染"></a>三维渲染</h5><p>Solid Modeling &amp;. Volume Rendering</p>
<p>广泛应用于物体渲染，如核磁共振等扫描后得到的体积信息，通过这些信息进行渲染，得到结果</p>
<table>
<thead>
<tr>
<th>程序纹理</th>
<th>预计算着色</th>
<th>三维渲染</th>
</tr>
</thead>
<tbody><tr>
<td><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\程序纹理.png" alt="程序纹理"></td>
<td><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\预计算着色.png" alt="预计算着色"></td>
<td><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\三维渲染.png" alt="三维渲染"></td>
</tr>
</tbody></table>
<h2 id="五、几何"><a href="#五、几何" class="headerlink" title="五、几何"></a>五、几何</h2><h3 id="几何的表达方式"><a href="#几何的表达方式" class="headerlink" title="几何的表达方式"></a>几何的表达方式</h3><h4 id="隐式几何"><a href="#隐式几何" class="headerlink" title="隐式几何"></a>隐式几何</h4><p>用空间中的满足一定条件的点的集合来表示面，隐式几何不会表示点的具体位置信息，而是告诉我们这些点满足的函数关系</p>
<p>我们很难看出隐式想表达的形状是什么，但对于判断点的位置关系（在内，在外还是在表面）会很方便</p>
<ul>
<li><p><strong>代数曲面</strong></p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\代数几何.png" alt="代数几何"></p>
</li>
<li><p><strong>CSG构造实体几何</strong></p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\CSG构造实体几何.png" alt="CSG构造实体几何"></p>
</li>
<li><p><strong>※ 距离函数</strong></p>
<p>对于任意一个几何，不直接描述其表面，而是描述空间中任意一点到这个表面的距离，如此一来空间中所有点都会被定义出一个距离值，把距离函数做出来，在做个belnding就可以达到融合效果</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\距离函数2.png" alt="距离函数2"></p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\距离函数1.png" alt="距离函数1"></p>
<p>距离函数应用：SDF</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\SDF.png" alt="SDF"></p>
<p>得到距离函数后，函数值为0的地方就是表面。类似的，水平集也用了同样的思想，在地理上类似定义是等高线，用等高线的思想确定表面位置</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\水平集.png" alt="水平集"></p>
<p>水平集应用：CT扫描</p>
</li>
<li><p><strong>分形几何</strong></p>
<p>自相似，递归，很难控制形状</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\分形几何.png" alt="分形几何"></p>
</li>
</ul>
<h4 id="显式几何"><a href="#显式几何" class="headerlink" title="显式几何"></a>显式几何</h4><p>直接给出点的位置，或者可以进行参数映射；然而想要判断内外时，显式的表达就很难进行表示</p>
<p><strong>点云</strong></p>
<p>用空间中一堆点的集合来表示物体，只要点足够密集，就看不到点与点之间的空隙，理论上可以表示任何几何，通常三维扫描得到的结果就是点云（点云可以转变为三角形）</p>
<p><strong>多边形网格</strong></p>
<p>或许是目前最为广为流传的三维几何表达方式</p>
<h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><p>德卡斯特里奥（de Casteljau）算法  生成<u>二次贝塞尔曲线</u></p>
<p>定义三个点 -&gt; 根据任意的 t 插值出点 -&gt; 不断重复 t在[0,1]间不断取值 -&gt; 得到曲线</p>
<p>![贝塞尔曲线 (3)](F:-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲线 (3).png)</p>
<p><u>二次贝塞尔曲线</u>：<strong>递归</strong></p>
<table>
<thead>
<tr>
<th>![贝塞尔曲线 (2)](F:-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲线 (2).png)</th>
<th>![贝塞尔曲线 (1)](F:-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲线 (1).png)</th>
</tr>
</thead>
</table>
<h4 id="贝塞尔曲线的代数表示"><a href="#贝塞尔曲线的代数表示" class="headerlink" title="贝塞尔曲线的代数表示"></a>贝塞尔曲线的代数表示</h4><p>在每两个之间找一个时间t，相当于每两个之间线性插值</p>
<p>![贝塞尔曲线的代数表示 (2)](F:-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲线的代数表示 (2).png)</p>
<p>把算法过程写成代数的形式（如图）</p>
<p>![贝塞尔曲线的代数表示 (4)](F:-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲线的代数表示 (4).png)</p>
<p>推广到n阶，不难发现这其实是一个符合二项分布的多项式</p>
<p>![贝塞尔曲线的代数表示 (1)](F:-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲线的代数表示 (1).png)</p>
<p>三次贝塞尔曲线的代数表示：</p>
<p>![贝塞尔曲线的代数表示 (3)](F:-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲线的代数表示 (3).png)</p>
<h4 id="贝塞尔曲线的性质"><a href="#贝塞尔曲线的性质" class="headerlink" title="贝塞尔曲线的性质"></a>贝塞尔曲线的性质</h4><ul>
<li>对称性：第 $i$ 项系数和倒数第 $i$ 项系数相同</li>
<li>必过起点终点，起始切线方向为前两个点连接的方向，终止切线方向为结尾两个点连接的方向</li>
<li>在仿射变换下，只需要对顶点做仿射变换，就能得到这个贝塞尔曲线在仿射变换下的结果</li>
<li>凸包性质：贝塞尔曲线始终会在<strong>包含了所有控制点的最小凸多边形</strong>中, 而不是按照控制点的顺序围成的最小多边形</li>
</ul>
<h4 id="逐段贝塞尔曲线"><a href="#逐段贝塞尔曲线" class="headerlink" title="逐段贝塞尔曲线"></a>逐段贝塞尔曲线</h4><p>控制点多了以后，贝塞尔曲线并不直观，很难控制，于是我们想到可以每次定义一段贝塞尔曲线，然后连起来</p>
<p>普遍习惯每四个控制点定义一段，并略去中间两点间的连线</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\逐段贝塞尔曲线.png" alt="逐段贝塞尔曲线"></p>
<h4 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h4><table>
<thead>
<tr>
<th>$C_0$连续：点相同</th>
<th>$C_1$连续：切线相同</th>
</tr>
</thead>
<tbody><tr>
<td><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\c0连续.png" alt="c0连续"></td>
<td><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\c1连续.png" alt="c1连续"></td>
</tr>
</tbody></table>
<h4 id="样条曲线"><a href="#样条曲线" class="headerlink" title="样条曲线"></a>样条曲线</h4><p><strong>样条</strong>：连续的曲线，由一系列控制点控制，满足一定的连续性，即可控的曲线</p>
<p><strong>B样条曲线</strong>有关信息可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50626506">https://zhuanlan.zhihu.com/p/50626506</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13441127CH?p=13">https://www.bilibili.com/video/BV13441127CH?p=13</a> 胡事民老师的课</p>
<h3 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h3><h4 id="贝塞尔曲面"><a href="#贝塞尔曲面" class="headerlink" title="贝塞尔曲面"></a>贝塞尔曲面</h4><p>u方向上画出四条贝塞尔曲线后，在这四个线上再取四个点，并认为这是个点是一组新的贝塞尔曲线的控制点，这些点在空间内向v方向扫描，便形成了贝塞尔曲面</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲面.gif" alt="贝塞尔曲面"></p>
<h3 id="几何处理"><a href="#几何处理" class="headerlink" title="几何处理"></a>几何处理</h3><h4 id="曲面细分"><a href="#曲面细分" class="headerlink" title="曲面细分"></a>曲面细分</h4><h5 id="Loop细分（涡轮平滑）"><a href="#Loop细分（涡轮平滑）" class="headerlink" title="Loop细分（涡轮平滑）"></a>Loop细分（涡轮平滑）</h5><p>连接各边中点，并重新改变各个顶点位置，从而创造出更多三角形面，使得表面更加光滑（命名并不是因为算法与循环有关，而是该算法创始人的名字叫loop）</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/loop%E7%BB%86%E5%88%86.png" alt="loop细分"></p>
<p>该算法规定，一般情况下（不考虑边缘情况），对于新顶点，位置由下左图规定，而对于旧顶点，需要由旧顶点和新顶点位置共同确定</p>
<p>下右图中，n为该顶点的度（依附于某个顶点的边的条数），u为一个和n有关的数</p>
<table>
<thead>
<tr>
<th>新顶点</th>
<th>旧顶点</th>
</tr>
</thead>
<tbody><tr>
<td><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/loop%E7%BB%86%E5%88%86%E6%96%B0%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE.png" alt="loop细分新顶点位置"></td>
<td><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/loop%E7%BB%86%E5%88%86%E6%97%A7%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE%E8%B0%83%E6%95%B4.png" alt="loop细分旧顶点位置调整"></td>
</tr>
</tbody></table>
<h5 id="Catmull-Clark-细分"><a href="#Catmull-Clark-细分" class="headerlink" title="Catmull-Clark 细分"></a>Catmull-Clark 细分</h5><p>loop细分有一个前提，即只适用于三角形网格，而对于非三角形网格的细分，就需要借助catmull-clark算法</p>
<p>该算法定义面分为两种——四边面和非四边面，并定义度为4的顶点为非奇异点，其余点均为奇异点</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/catmull%EF%BC%881%EF%BC%89.png" alt="catmull（1）"></p>
<p>具体做法是，对每个非四边面都取其中的一个点（重心或者其他点），将其与该面的其他顶点分别连接，在这个过程中，会引入一个新的奇异点，并且在一次细分后，所有非四边面都变为了四边面，在后续的细分中，将不会引入新的奇异点</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/catmull%EF%BC%882%EF%BC%89.png" alt="catmull（2）"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/catmull%EF%BC%883%EF%BC%89.png" alt="catmull（3）"></th>
</tr>
</thead>
</table>
<p>对于细分后顶点位置的调整，先将顶点分为三大类</p>
<p>①新的在面上的点；②新的在边上的点；③旧的点</p>
<p>如下计算：</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/catmull%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE%E8%B0%83%E6%95%B4.png" alt="catmull顶点位置调整"></p>
<p>loop细分与catmull-clark细分不同的处理效果：</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/loop%E4%B8%8Ecatmull%E5%AF%B9%E6%AF%94.png" alt="loop与catmull对比"></p>
<p>具体推导过程可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/McQueen_LT/article/details/106102609">https://blog.csdn.net/McQueen_LT/article/details/106102609</a></p>
<h4 id="网格简化"><a href="#网格简化" class="headerlink" title="网格简化"></a>网格简化</h4><h5 id="边坍缩"><a href="#边坍缩" class="headerlink" title="边坍缩"></a>边坍缩</h5><p>如何保证坍缩前后轮廓基本保持一致？	——二次误差</p>
<p>二次误差度量：坍缩后的点和原本几个边（面）的距离的平方和最小</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/%E4%BA%8C%E6%AC%A1%E8%AF%AF%E5%B7%AE%E5%BA%A6%E9%87%8F.png" alt="二次误差度量"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/%E4%BA%8C%E6%AC%A1%E8%AF%AF%E5%B7%AE%E5%BA%A6%E9%87%8F2.png" alt="二次误差度量2"></th>
</tr>
</thead>
</table>
<p>对每一条边都先计算一下二次误差，随后从二次误差最小的开始坍缩，由小到大</p>
<p>但这么做会引入一些问题：做一次坍缩后，其他边也跟着变了，他们的二次误差必须被重新计算</p>
<p>所以需要从二次度量误差中选最小的，取完最小的之后，我们要对它们的二次误差做一次更新，于是我们就要用到&#x3D;&#x3D;优先队列 &#x2F; 堆&#x3D;&#x3D;这种数据结构，这种数据结构能让我们能取得二次误差最小值的同时也能动态更新其他受影响的元素</p>
<p>另外，这种通过对局部计算最优解，试图找到全局的最优解，是一个典型的贪心算法</p>
<h2 id="六、光线追踪"><a href="#六、光线追踪" class="headerlink" title="六、光线追踪"></a>六、光线追踪</h2><p>光栅化的着色是一种局部的现象，在其着色的过程中只会考虑着色点自己的信息，而不会考虑其他物体，甚至不会考虑物资自身的其他部分对着色点的影响。事实上这些都是会有遮挡的关系的，是会产生阴影的，为了解决这个问题，就有了光线追踪</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><h4 id="Shadow-Mapping-阴影贴图"><a href="#Shadow-Mapping-阴影贴图" class="headerlink" title="Shadow Mapping 阴影贴图"></a>Shadow Mapping 阴影贴图</h4><p>核心思想：如果一个点不在阴影里，那么这个点可以被摄像机和光源都看到</p>
<p>局限：硬阴影，走样，只能处理点光源</p>
<p>具体实现细节：</p>
<p>① 先从光源看向场景，做一遍光栅化，不进行着色，只记录深度</p>
<p>② 再从摄像机看向场景，再做一遍光栅化，记录深度</p>
<p>③ 比较两次深度值，如果不相等，则说明该点在阴影中</p>
<p><strong>问题1</strong>：渲染出来的阴影比较脏</p>
<p><strong>原因</strong>：深度值的比较位浮点数比较，而判断浮点数相等势必会产生误差，虽然处理精度的方法有很多种，但并不能从本质上解决问题</p>
<p><strong>问题2</strong>：走样</p>
<p><strong>原因</strong>：本身储存的深度图存在分辨率限制，与渲染时的分辨率搭配不好的话，就会产生走样</p>
<p>![Shadow Mapping浮点误差](F:-STUDY-\college\闫令琪_图形学入门\101\图片\p13-光线追踪\Shadow Mapping浮点误差.png)</p>
<p>关于硬软阴影：本质是本影和半影的问题，只要存在软阴影，那么光源一定具有一定的体积</p>
<h4 id="Why-Ray-Tracing？"><a href="#Why-Ray-Tracing？" class="headerlink" title="Why Ray-Tracing？"></a>Why Ray-Tracing？</h4><p>由上可知，光栅化并做不好全局的效果，如软阴影，反射，环境光照</p>
<p>光栅化很快速，但渲染的质量不高；光线追踪的处理速度慢，但渲染的很准确</p>
<p>光栅化很容易做到实时，而光线追踪更多的应用于离线渲染（现在的实时光线追踪，这位更是重量级！）</p>
<p>首先定义光线——沿直线传播，不会发生碰撞，从光源到人眼</p>
<p>由光路的可逆性，在光线追踪的具体应用中，采用从人眼（认为是一个针孔摄像机）到光源的方法</p>
<p><strong>光线投射</strong>：人眼，成像平面，光源，物体</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p13-光线追踪\光线投射.png" alt="光线投射"></p>
<p><u>从相机出发投射一条光线</u>，穿过成像平面，与着色点相连，如果光源能看见着色点（着色点不在阴影中），那么就生成一条有效光路，计算能量并着色（我们很容易知道这个着色点的法线，入射方向等信息，这时候可以用各种各样的着色模型（如Blinn Phong））</p>
<p>对于场景中的物体，我们假设光打到它之后会发生完美的折射与反射，而对于着色点，我们取光路与物体最近的交点（涉及深度测试）</p>
<p>总的来说，光线投射其实就是每个像素投射出去一条光线，求到和场景内物体的最近交点，通过该交点和光源连线来判定是否可见，然后算着色，写回像素的值</p>
<p>这个方法依旧只是弹射一次，但事实上光线是能在物体间弹射很多次，这时候就需要用到whitted光线追踪</p>
<h3 id="Whitted（递归）风格光线追踪"><a href="#Whitted（递归）风格光线追踪" class="headerlink" title="Whitted（递归）风格光线追踪"></a>Whitted（递归）风格光线追踪</h3><p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p13-光线追踪\whitted光线追踪.png" alt="whitted光线追踪"></p>
<p>如果图中的球是玻璃材质，那么之前从像素投射出去的光线，除了会在玻璃球表面发生发射，还有一部分会进入玻璃球发生折射，而whitted光线追踪，除了计算第一次光线投射的着色点外，对每个弹射点也进行了着色计算（损失多少能量，颜色值等）</p>
<h3 id="光线与物体求交"><a href="#光线与物体求交" class="headerlink" title="光线与物体求交"></a>光线与物体求交</h3><p>无论是之前的光线投射还是whitted风格光线追踪，都涉及到光线与物体求交问题</p>
<p>为了研究这个问题，我们需要先定义光线</p>
<p>一个光线可以有一个点（光源）和一个方向（光线方向）确定，则可设光线表达式：$r(t)&#x3D;O+td$</p>
<h4 id="和隐式表面求交"><a href="#和隐式表面求交" class="headerlink" title="和隐式表面求交"></a>和隐式表面求交</h4><p>光线在t时间后到达的着色点：$r(t)&#x3D;O+td$</p>
<p>隐式表面：$f(p)&#x3D;0$	<code> //p是着色点</code></p>
<p>将$r(t)$代入，$f(r(t))&#x3D;f(O+td)&#x3D;0$</p>
<p>要判断是否与隐式表面相交，只要判断上面这个方程是否有解即可</p>
<p><img src="F:-STUDY-\college\闫令琪_图形学入门\101\图片\p13-光线追踪\与隐式表面求交.png" alt="与隐式表面求交"></p>
<h4 id="和显式表面求交"><a href="#和显式表面求交" class="headerlink" title="和显式表面求交"></a>和显式表面求交</h4><p>核心：点如果在封闭形状内，向外打一条光线，得到的交点数量一定是奇数；如果在封闭形状外，则交点数一定是偶数</p>
<p>那么对于显示表面求交，最简单的做法就是遍历物体的所有三角形面，求交点数量，那么问题就简化为如何判断光线与三角形面求交（这种方法很慢，之后会提到包围盒的加速算法）</p>
<h4 id="与三角面求交"><a href="#与三角面求交" class="headerlink" title="与三角面求交"></a>与三角面求交</h4><p>平面可以由一个点和一个法线定义，三角面也不例外，在求交问题中，设光线和三角面交点位p，p满足：$(p-p’)·N&#x3D;0$</p>
<p>复杂的做法是，将光线方程带入三角面方程，求得交点（下图），在用向量积判断交点是否在三角面内</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p13-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/%E4%B8%8E%E6%98%BE%E5%BC%8F%E8%A1%A8%E9%9D%A2%E6%B1%82%E4%BA%A4%EF%BC%881%EF%BC%89.png" alt="与显式表面求交（1）"></p>
<p>简便的做法，把求交点和判断这两步并作一步，即Möller-Trumbore算法</p>
<h4 id="Moller-Trumbore算法"><a href="#Moller-Trumbore算法" class="headerlink" title="Möller-Trumbore算法"></a>Möller-Trumbore算法</h4><p>如下图，左边是光线上的点，右边是用重心坐标表示的三角形内的点</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p13-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/M%C3%B6ller-Trumbore%E7%AE%97%E6%B3%95.png" alt="Möller-Trumbore算法"></p>
<p>解出来之后要判断是否合理， $t&gt;0？\ \ \ b_1,b_2,b_3&gt;0？$</p>
<p>算法推导：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhanxi1992/article/details/109903792">https://blog.csdn.net/zhanxi1992/article/details/109903792</a></p>
<h4 id="轴对齐包围盒（AABB）求交"><a href="#轴对齐包围盒（AABB）求交" class="headerlink" title="轴对齐包围盒（AABB）求交"></a>轴对齐包围盒（AABB）求交</h4><p>上述算法的计算次数： 像素数×三角形数×弹射次数</p>
<p>显然，对每一帧来说，这样的计算量是非常大的，所以我们需要引入包围盒，将一个复杂的物体用简单的形状围起来</p>
<p>那么如果光线连包围盒都碰不到，那肯定碰不到包围盒里的物体</p>
<p>对于三维的情况，我们一般用长方体包围盒，更特殊的，轴对齐包围盒，即包围盒的每一个边都对应和一个坐标轴平行</p>
<p>接着就来考虑光线和包围盒求交的问题</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p13-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/AABB%E5%8C%85%E5%9B%B4%E7%9B%92.png" alt="AABB包围盒"></p>
<p>只有当光线进入了三组对面，才能说明光线进入了包围盒，同理，当光线在三组对面外，才可知光线离开了包围盒</p>
<p>如上图，取$t_{min}$里的max，作为进入包围盒的时间，取$t_{max}$里的min，作为离开包围盒的时间</p>
<p>若进入包围盒的时间小于离开包围盒的时间，说明有交点</p>
<p><strong>几个问题</strong>：光线是射线，如果t是负数，那说明交点在射线的反向延长线上，这是不合理的，下面做分类讨论：</p>
<ul>
<li>盒子在光线背后：${t_{enter}}&lt;0,t_{output}&lt;0$</li>
<li>光线起点在盒子内部：$t_{enter}&lt;0,t_{output}&gt;0$</li>
</ul>
<p>综上，$iff\ \ \ t_{enter}&lt;t_{output}且t_{output}&gt;0$，此时才能证明光线和包围盒有交点</p>
<p>why AABB？为什么使用轴对称包围盒？</p>
<p>因为轴对齐的情况下，我们可以在求t的时候只求某一轴的信息（光线在轴上的投影），而不用整个坐标，比点乘计算会更加容易</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p13-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%BD%B4%E5%AF%B9%E7%A7%B0%E5%8C%85%E5%9B%B4%E7%9B%92.png" alt="为什么使用轴对称包围盒"></p>
<h4 id="使用轴对齐包围盒加速光线追踪"><a href="#使用轴对齐包围盒加速光线追踪" class="headerlink" title="使用轴对齐包围盒加速光线追踪"></a>使用轴对齐包围盒加速光线追踪</h4><p>通过上述分析，我们已经知道了光线如何和包围盒求交，那么又要怎么在空间中确定这些包围盒的位置呢</p>
<p>（需要注意，以下对空间的划分都是光线追踪的预处理操作）</p>
<h5 id="均匀划分"><a href="#均匀划分" class="headerlink" title="均匀划分"></a>均匀划分</h5><p>假设光线与物体求交比光线与包围盒求交慢的多，那么我们需要对包围盒进行进一步加工</p>
<p>均匀划分的步骤如下：</p>
<p>找到场景包围盒 -&gt; 均匀划分该包围盒 -&gt; 判定与物体相交的子包围盒 -&gt; 与物体求交</p>
<p>如果一条光线向右上投射出去，为了确定这条光线与哪些子包围盒相交，简单的想法是他下一次交到的包围盒在他当前交到的右边或上边（如何光栅化一条线）</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/%E5%9D%87%E5%8C%80%E5%88%92%E5%88%86%E7%A9%BA%E9%97%B4%E6%AD%A5%E9%AA%A4.png" alt="均匀划分空间步骤"></p>
<p>所谓加速就是多做光线与盒子求交，少做光线与物体求交，那么我们来看一下均匀划分的加速效果</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/%E5%9D%87%E5%8C%80%E5%88%92%E5%88%86%E7%9A%84%E5%A4%AA%E5%B0%91.png" alt="均匀划分的太少"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/%E5%9D%87%E5%8C%80%E5%88%92%E5%88%86%E7%9A%84%E5%A4%AA%E5%A4%9A.png" alt="均匀划分的太多"></th>
</tr>
</thead>
</table>
<p>如果划分成1×1的格子，则没有加速效果；如果划分太密集，效率也不会高</p>
<p>根据经验，人们大概得出划分成场景中物体数目的27倍的格子数比较好</p>
<p>&#x3D;&#x3D;格子的划分方法在大量均匀分布的物体上比较有效，然而在复杂空旷的场景中，会造成很多资源浪费&#x3D;&#x3D;</p>
<h5 id="空间划分"><a href="#空间划分" class="headerlink" title="空间划分"></a>空间划分</h5><p>在网格均匀划分中划分出来的都是大小相同的格子，但在有些空旷的地方不需要这样划分，太浪费了，我们想在没物体的地方用大盒子，有物体的地方用密集的盒子，这也就引出了空间划分的方法</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86.png" alt="空间划分"></p>
<h6 id="八叉树"><a href="#八叉树" class="headerlink" title="八叉树"></a>八叉树</h6><p>每一次把空间划分成八份，直到满足一定的停止规则（比如某一次划分8个子空间中7个为空）</p>
<p><u>缺点：维数越高越复杂，n维空间对应$2^n$叉树</u></p>
<h6 id="BSP树"><a href="#BSP树" class="headerlink" title="BSP树"></a><strong>BSP树</strong></h6><p>一种对空间二分的划分方法，每次选一个方向进行划分，与KD树的区别在于它不是横平竖直地切，且它会有越高维越不好计算的问题（砍开二维用线，砍开三维用面，维度越高越复杂）</p>
<h6 id="KD树"><a href="#KD树" class="headerlink" title="KD树"></a>KD树</h6><p>每次把空间划分为两份，x，y，z轴轮流切分，直到被切分节点中不存在物体则停止</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/KD%E6%A0%91.png" alt="KD树"></p>
<p><u>KD树如何加速光线追踪：</u></p>
<p>如图，如果一条光线与当前结点空间有交点，则继续寻找该结点的子节点，直到找到叶子结点，再与其中物体求交</p>
<p><u>缺点：</u></p>
<p>给出一个节点的包围盒，要判断他与物体哪些三角形有交集，才能进行后续着色，这种算法确实存在，但不太好写</p>
<p>其次，很多情况下一个物体和很多包围盒都有交集，它可能会存在很多个叶子节点中，会造成重复计算</p>
<p>由此我们引入另一种基于物体的划分方式——BVHs</p>
<h5 id="BVHs划分"><a href="#BVHs划分" class="headerlink" title="BVHs划分"></a>BVHs划分</h5><p>Bounding Volume Hierarchy</p>
<p>找到场景包围盒 -&gt; 每次将物体分为两堆 -&gt; 对两堆物体重新计算包围盒 -&gt; 直到一堆中物体少到一定程度</p>
<p>如何划分物体：</p>
<p>1°选取当前最长的轴的垂直方向作为划分方向</p>
<p>2°取中间的物体（第$\frac{n}{2}$个三角形）（快速选择算法）</p>
<p>1°或2°都可以，主要是为了保证二叉树的平衡（平衡二叉树？）</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/BVHs.png" alt="BVHs"></p>
<p>BVH这种储存结构，中间结点储存包围盒和子节点的指针，叶子结点储存包围盒和物体（的集合）</p>
<p>关于BVH如何加速光线追踪，可以参考下述伪代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Intersect(Ray ray,BVH node)</span><br><span class="line">&#123;</span><br><span class="line">	if(node is a leaf node)</span><br><span class="line">	&#123;</span><br><span class="line">		test intersection with all objs;</span><br><span class="line">		return closest intersection;</span><br><span class="line">	&#125;</span><br><span class="line">	hit1 = Intersect(ray , node.child1);</span><br><span class="line">	hit2 = Intersect(ray , node.child2);</span><br><span class="line">	</span><br><span class="line">	return the closer of hit1,hit2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BVHs-vs-KD"><a href="#BVHs-vs-KD" class="headerlink" title="BVHs vs. KD"></a>BVHs vs. KD</h5><p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/BVH%20vs.%20KD.png" alt="BVH vs. KD"></p>
<p>一个是对空间的划分，一个是基于物体的划分；KD树的包围盒不会发生重合，而BVHs会发生相交</p>
<h3 id="辐射度量学基础"><a href="#辐射度量学基础" class="headerlink" title="辐射度量学基础"></a>辐射度量学基础</h3><p>why：</p>
<p>Blinn-Phong着色模型中会设置一个数当做光照强度，但我们都不清楚这个数的真实的物理意义，甚至连单位是什么也不知道，研究过程中我们只是将这些物理量简化为一个数，另外Whitted风格的光线追踪所得到的结果也不是我们所想要的真实的效果（路径追踪会提到），而所有的这些都会被辐射度量学解决，这同样也是后面学习路径追踪的基础</p>
<p>辐射度量学给出了一系列度量方法和单位去定义光照，它定义了光照在空间中的属性，并且这在物理上是完全正确的</p>
<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><table>
<thead>
<tr>
<th align="center">物理量</th>
<th align="center">符号</th>
<th align="center">中文翻译</th>
<th align="center">简单定义</th>
<th align="center">单位</th>
<th align="center">公式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Radiant Energy</td>
<td align="center">Q</td>
<td align="center">辐射能量</td>
<td align="center">电磁波形式的能量</td>
<td align="center">焦耳（J）</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">Radiant Flux</td>
<td align="center">P</td>
<td align="center">辐射功率&#x2F;辐射通量</td>
<td align="center">单位时间内的辐射能量</td>
<td align="center">瓦特（w）</td>
<td align="center">$P&#x3D;\frac{dQ}{dt}$</td>
</tr>
<tr>
<td align="center">Radiant Intensity</td>
<td align="center">I</td>
<td align="center">辐射强度</td>
<td align="center">点源向某单位立体角发射的辐射功率</td>
<td align="center">w&#x2F;sr</td>
<td align="center">$I&#x3D;\frac{dP}{d\omega}$</td>
</tr>
<tr>
<td align="center">Irradiance</td>
<td align="center">E</td>
<td align="center">辐（射）照度</td>
<td align="center">受照面单位面积上的辐射功率</td>
<td align="center">w$&#x2F;m^2$</td>
<td align="center">$E&#x3D;\frac{dP}{dA}$</td>
</tr>
<tr>
<td align="center">Radiance</td>
<td align="center">L</td>
<td align="center">辐（射）亮度</td>
<td align="center">单位投影面积、单位立体角上的辐射功率</td>
<td align="center">w$&#x2F;m^2$sr</td>
<td align="center">$L&#x3D;\frac{d^2P}{dAd\omega cos(\theta)}$</td>
</tr>
</tbody></table>
<p>光学中辐射强度的单位：$\frac{W}{sr}&#x3D;\frac{lm}{sr}&#x3D;candela&#x3D;cd$</p>
<p>$\Omega&#x2F;\omega$：立体角；$A$：受照面面积</p>
<p>sr：球面度，立体角国际单位</p>
<p>lm：流明，光通量国际单位</p>
<p>cd：坎德拉，光强单位，SI 7大基本单位之一</p>
<p>光通量和辐射通量：</p>
<p>光通量与辐射通量的量纲相同，但辐射通量是一个辐射度量学上的概念，是一个描述光源辐射强弱程度的客观物理量，而光通量是一个光 学概念，是一个属于把辐射通量与人眼的视觉特性联系起来评价的主观物理量，或者说光通量是按光对人眼所激起的明亮感觉程度所估计的辐射通量</p>
<h4 id="立体角"><a href="#立体角" class="headerlink" title="立体角"></a>立体角</h4><p>为了理解光线在空间中辐射的过程，我们需要引入立体角的概念</p>
<p>平面情况下，弧度制角度可以由$\theta&#x3D;\frac{l}{r}$计算得到，仿照二维情况，立体角可以由$\omega&#x3D;\frac{A}{r^2}$定义</p>
<p>其中A如图所示，是立体角锥体在球面上截出的一块面积</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/%E7%AB%8B%E4%BD%93%E8%A7%92%E6%A6%82%E5%BF%B51.png" alt="立体角概念1"></p>
<p>采用微分的思想求A的面积，可由简单推导得到<br>$$<br>dA&#x3D;(r·d\theta)·(rsin(\theta)·d\phi)&#x3D;r^2sin(\theta)d\phi d\theta\<br>d\omega&#x3D;\frac{dA}{r^2}&#x3D;sin(\theta)d\phi d\theta<br>$$<br><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/%E5%BE%AE%E5%88%86%E7%AB%8B%E4%BD%93%E8%A7%92.png" alt="微分立体角"></p>
<p>对微分立体角进行全积分，可以得到立体角的范围<br>$$<br>\Omega&#x3D;\int_{S^2}\int_0^\pi sin(\theta)d\phi d\theta&#x3D;4\pi\<br>\omega\in[0,4\pi]<br>$$<br>具体推导过程参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/LoseInVain/article/details/108630648">https://blog.csdn.net/LoseInVain/article/details/108630648</a></p>
<h4 id="Irradiance（辐照度）"><a href="#Irradiance（辐照度）" class="headerlink" title="Irradiance（辐照度）"></a>Irradiance（辐照度）</h4><p>定义：受照面单位面积上的辐射功率，即在单位时间内，每个单位面积上接受到的光照的能量</p>
<p>公式：$E&#x3D;\frac{\mathrm{d}P}{\mathrm{d}A}·cos(\theta)&#x3D;\frac{\mathrm{d}Q}{\mathrm{d}A\mathrm{d}t}·cos(\theta)$</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E8%BE%90%E7%85%A7%E5%BA%A6.png" alt="辐照度"></p>
<p>将辐射度量学里的功率换成光学里的流明，公式同样成立，光学中辐照度对应物理量为lux（勒克斯）</p>
<p>同样类似Blinn-Phone模型，这里也需要考虑光线和受照面的角度问题</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E5%85%B0%E4%BC%AF%E7%89%B9%E4%BD%99%E5%BC%A6%E5%AE%9A%E7%90%86.png" alt="兰伯特余弦定理"></p>
<p>如上三图，兰伯特余弦定理</p>
<p>左图光线垂直受照面，直接代公式；中图夹角60°，六根光线只照到三根，乘cos60°结果正确</p>
<p>更普遍的情况如右图，要乘以光线和受照面法线的夹角，写进代码就是 $l·n$</p>
<p>兰伯特余弦定理也可以解释地球的四季变换，北半球夏天太阳直射北半球，北半球的Irradiance当然更多，也就更热；而当北半球是冬天的时候，光线与北半球地球表面的夹角变大，cos值变小，Irradiance减少，冬天也就更冷</p>
<p>而在讲Blinn-Phone漫反射模型的时候，我们曾提到过，光照的辐射能量可以假设集中在一个球壳上，同一球面上光能处处相等，而随着球壳半径的增长，单位面积上的光能也呈$r^2$衰减</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E8%BE%90%E7%85%A7%E5%BA%A6%E8%A1%B0%E5%87%8F.png" alt="辐照度衰减"></p>
<p>如图，在最里面的单位球上$E&#x3D;\frac{P}{4\pi}$，而在外层球壳上，$E’&#x3D;\frac{P}{4\pi r^2}&#x3D;\frac{E}{r^2}$</p>
<p>在学了辐照度概念之后，我们就可以知道这里光能衰减的并不是Radiant Intensity，而是Irradiance</p>
<p>对于Radiant Intensity，随r的增长，它的值保持不变</p>
<h4 id="Radiance（辐亮度）"><a href="#Radiance（辐亮度）" class="headerlink" title="Radiance（辐亮度）"></a>Radiance（辐亮度）</h4><p>定义：单位投影面积、单位立体角上的辐射功率，是描述环境中光的分布的基本场量</p>
<p>公式：<br>$$<br>L&#x3D;\frac{\mathrm{d}^2P}{\mathrm{d}Ad\omega cos(\theta)}<br>$$<br>注意这里的2是二次微分标记，即$dA,d\omega$各做一次微分，不是平方标记！</p>
<p>准确的光线追踪与radiance的关系非常大，其渲染就是在计算radiance</p>
<p>同样的，对于光学来说，辐亮度也有他自己的另一个单位，nit（尼特）<br>$$<br>[\frac{w}{m^2sr}][\frac{cd}{m^2}&#x3D;\frac{lm}{m^2sr}&#x3D;nit]<br>$$</p>
<h4 id="Radiance-Irradiance-Intensity之间的联系与区别"><a href="#Radiance-Irradiance-Intensity之间的联系与区别" class="headerlink" title="Radiance &amp; Irradiance &amp; Intensity之间的联系与区别"></a>Radiance &amp; Irradiance &amp; Intensity之间的联系与区别</h4><p>从公式看起<br>$$<br>L&#x3D;\frac{\mathrm{d}^2P}{\mathrm{d}Ad\omega cos(\theta)};\ \ \<br>I&#x3D;\frac{\mathrm{d}P}{\mathrm{d}\omega};\ \ \<br>E&#x3D;\frac{\mathrm{d}P}{\mathrm{d}A}\<br>L&#x3D;\frac{\mathrm{d}E}{\mathrm{d}\omega cos(\theta)}^①<br> &#x3D;\frac{\mathrm{d}I}{\mathrm{d}A cos(\theta)}^②<br>$$<br>从放射（放出能量）的角度来解释，Radiance表示单位面积上 因吸收了能量 而朝某个方向&#x3D;&#x3D;辐射出去多少能量&#x3D;&#x3D;</p>
<p>从入射（吸收能量）的角度来解释，Radiance表示单位面积上 所有接收到的能量中的某一束，即&#x3D;&#x3D;Irradiance在某一方向上的分量&#x3D;&#x3D;</p>
<p>而对于Intensity，辐射强度代表的是所有在某一单位立体角方向上辐射出的能量</p>
<p>Radiance代表这个Intensity在某个单位面积dA上的投影 &#x2F; 分量</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E8%BE%90%E7%85%A7%E5%BA%A6&%E8%BE%90%E4%BA%AE%E5%BA%A6.png" alt="辐照度&amp;辐亮度"></p>
<p>Radiance和Irradiance的区别和联系在图形学中非常重要，总结来说就是：</p>
<p>Radiance是某个单位面积向某个单位立体角辐射出去的能量，Irradiance是某个单位面积上接受到来自四面八方的能量</p>
<p>区别就在于辐亮度Radiance有方向的概念，而辐照度Irradiance没有</p>
<p>把半球面上的所有Radiance积分起来得到的就是Irradiance</p>
<h3 id="双向反射分布函数（BRDF）"><a href="#双向反射分布函数（BRDF）" class="headerlink" title="双向反射分布函数（BRDF）"></a>双向反射分布函数（BRDF）</h3><p>BRDF：Bidirectional Reflectance Distribution Function  双向反射分布函数</p>
<p>BSDF：Bidirectional Scattering Distribution Function  双向散射分布函数</p>
<p>BTDF：Bidirectional Transmittance Distribution Function  双向透射分布函数</p>
<p>BSSRDF：Bidirectional Scattering-Surface Reflectance Distribution Function  双向散射表面反射（次表面散射）分布函数</p>
<p>以上为PBR知识体系下渲染方程所涉及的BxDF</p>
<p>回归正题，我们之前所说的反射情况，当发生镜面反射时，光线会朝一个方向反射，当发生漫反射时，光线会向四面八方反射</p>
<p>在我们之前的理解中，反射就是光线到达物体表面后偏移到另一个方向，而在学了辐射度量学之后，我们可以换一个角度思考这个过程</p>
<p>假设光线到达物体表面后，被物体表面吸收，而后再由物体表面发射到其他方向去，也就是用Radiance和Irradiance来解释反射</p>
<p><strong>吸收过程</strong>：$\mathrm{d}E(\omega_{input})&#x3D;L(\omega_{input})cos(\theta_{input})\mathrm{d}\omega_{input}$        参照①号公式</p>
<p>表示单位面积由$\omega_{input}$方向上的光线吸收得到的Irradiance</p>
<p><strong>辐射过程</strong>：$\mathrm{d}L(\omega_{output})\ \ \ (due\ \ to\ \ \mathrm{d}E(\omega_{input}))$</p>
<p>表示单位面积在经过吸收过程后向$\omega_{output}$方向上反射出去的Radiance</p>
<p>由上可知，我们很容易求得单位面积从某一方向吸收了多少能量，而很难求出吸收之后辐射出去的Radiance分布情况</p>
<p>于是我们就定义一种函数来描述这种Radiance的分布：<br>$$<br>\mathrm{d}L(\omega_{output})&#x3D;<br>f_r(\omega_{input}\rightarrow\omega_{output})·\mathrm{d}E(\omega_{input})\<br>f_r(\omega_{input}\rightarrow\omega_{output})&#x3D;<br>\frac{\mathrm{d}L(\omega_{output})}{\mathrm{d}E(\omega_{input})}<br>&#x3D;\frac{\mathrm{d}L(\omega_{output})}{L(\omega_{input})cos(\theta_{input})\mathrm{d}\omega_{input}}<br>$$<br>这个函数就是BRDF双向反射分布函数，其实它就是定义了一个比例（该比例由材质决定）<br>$$<br>f_r(\omega_{input}\rightarrow\omega_{output})&#x3D;\frac{吸收后向某立体角方向辐射出去的 Radiance}{辐射前某单位面积\mathrm{d}A接收到的Irradiance}<br>$$<br>表示的是一个吸收与辐射的转化比例，即某个光线打到物体表面后，往不同方向反射的能量分布</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/BRDF.png" alt="BRDF"></p>
<p>现在再来考虑镜面反射和漫反射，我们会发现镜面反射辐射出去的能量全都集中在反射方向上，而漫反射则是将吸收的能量均匀分配到了各个方向</p>
<p>如果忽略公式本身的推导过程，其实BRDF描述的就是物体和光线之间的相互作用</p>
<h3 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h3><h4 id="反射方程"><a href="#反射方程" class="headerlink" title="反射方程"></a>反射方程</h4><p>上述分析中，$dL(\omega_{output})$是某单位面积在$\omega_{input}$方向上吸收了$dE(\omega_{input})$后向$\omega_{output}$辐射的能量</p>
<p>而这仅仅是$\omega_{input}$方向上吸收得到的$dL(\omega_{output})$，我们的研究需要的是这个单位面积从各个方向上吸收了能量而在$\omega_{output}$上总共辐射的能量</p>
<p>因此我们需要对整个半球面求积分，来累加$dL(\omega_{output})$<br>$$<br>L(p,\omega_{exit})&#x3D;\int_{H^2}f_r(p,\omega_{input}\rightarrow\omega_{exit})·dE(p,\omega_{input})<br>&#x3D;\int_{H^2}f_r(p,\omega_{input}\rightarrow\omega_{exit})·<br>L(p,\omega_{input})cos(\theta_{input})d\omega_{input}<br>$$<br>方程的（）中多出来的p表示入射（反射）点</p>
<p>另外，在考虑反射方程的时候，我们还要注意：</p>
<p>反射点接受的能量（Irradiance）并不只是来自于光源，还会来自别的表面反射来的光（Irradiance）</p>
<p>从反射点反射出去的能量（Radiance）也并不只会反射到Camera或者人眼，还会作为Irradiance反射到其他的面上</p>
<p>所以理论上的反射方程定义应该带有递归的思想，也因此，光线反射的次数不同，得到的最终效果也就不会不同</p>
<p>但是我们目前先不考虑这些，暂且先用上面这个反射方程当做通用的方程</p>
<h4 id="渲染方程-1"><a href="#渲染方程-1" class="headerlink" title="渲染方程"></a>渲染方程</h4><p>渲染方程与反射方程相比只是多加了一个自发光的项</p>
<p>渲染效果 &#x3D; 反射光 + 自发光，方程如下：<br>$$<br>L(p,\omega_{output})&#x3D;L_{emission}+\int_{\Omega+}L(p,\omega_{input})·<br>f_r(p,\omega_{input}\rightarrow\omega_{output})·(n·\omega_{input})d\omega_{input}<br>$$<br>注意其中$\omega^+$和$H^2$是等价的，都是表示半球面 积分区域，并且在渲染方程中，假设入射出射所有的向量都是由内指向外的</p>
<h4 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h4><p>如果只有一个点光源，那么反射光&#x3D;自发光+入射光×BRDF×入射光与法线的夹角</p>
<p>如果有很多个点光源，那么反射光就是把所有点光源的反射光能量加起来<br>$$<br>L(p,\omega_{output})&#x3D;L_{emission}+\sum L(p,\omega_{input})·<br>f_r(p,\omega_{input}\rightarrow\omega_{output})·(n·\omega_{input})<br>$$<br>如果存在面光源，那么将这个面光源当成点光源的集合，求积分<br>$$<br>L(p,\omega_{output})&#x3D;L_{emission}+\int_{\Omega}L(p,\omega_{input})·<br>f_r(p,\omega_{input}\rightarrow\omega_{output})·(n·\omega_{input})d\omega_{input}<br>$$<br>如果不止光源，还有其他物体反射来的光，则把其他物体的反射面当成光源，递归<br>$$<br>L(p,\omega_{output})&#x3D;L_{emission}+\int_{\Omega}L(X’,\omega_{input})·<br>f_r(X’,\omega_{input}\rightarrow\omega_{output})·(n·\omega_{input})d\omega_{input}<br>$$<br><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B1.png" alt="渲染方程1"></p>
<h5 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h5><p>为方便后续理解，将整个渲染方程简写<br>$$<br>L(p,\omega_{output})&#x3D;L_{emission}+\int_{\Omega}L(X’,\omega_{input})·<br>f_r(X’,\omega_{input}\rightarrow\omega_{output})·(n·\omega_{input})d\omega_{input}\\downarrow\<br>L(u)&#x3D;e(u)+\int L(v)K(u,v)dv\\downarrow\<br>L&#x3D;E+KL<br>$$<br>e(u)：自发光<br>L(v)：吸收其他物体反射过来的光后辐射出来的Irradiance<br>K(u,v)：BRDF算子<br>u，v表示两个不同的反射位置</p>
<p>L、E是向量，K是算子&#x2F;矩阵</p>
<p>化简，求出L</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B2.png" alt="渲染方程2"></p>
<p>利用算子的运算性质（求逆以及泰勒展开）进一步对L进行变换</p>
<p>最后我们得到的L这种形式可以视作以 光的弹射次数 为区分的很多项，把光线弹射的次数的项累加起来，就得到了全局光照渲染方程</p>
<p>如果用渲染方程来理解光栅化，可以发现光栅化只做了全局光照的前两步，即自发光和直接光照</p>
<p>从这里再理解光线追踪一开始说的光栅化的不足，豁然开朗</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E7%94%A8%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E7%90%86%E8%A7%A3%E5%85%89%E6%A0%85%E5%8C%96.png" alt="用渲染方程理解光栅化"></p>
<p>随着展开次数的增加，渲染效果如下图所示</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A71.png" alt="全局光照1"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A72.png" alt="全局光照2"></th>
</tr>
</thead>
<tbody><tr>
<td><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A73.png" alt="全局光照3"></td>
<td><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A74.png" alt="全局光照4"></td>
</tr>
<tr>
<td><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A75.png" alt="全局光照5"></td>
<td><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A76.png" alt="全局光照6"></td>
</tr>
</tbody></table>
<p>前几张的对比效果非常明显，注意到两次反射和四次反射中，图片上方的灯由黑色转为透明，这是因为如果只做两次反射，光线只能被允许进入玻璃内，而无法从玻璃中透射出来，而四次反射则可以让光线从中射出，因此反射四次的灯是透明的</p>
<p>另外，不难发现8次反射和16次反射得到的结果并没有差太多，这也恰恰证明了渲染方程满足泰勒展开级数收敛这一性质</p>
<h3 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h3><p>需要用到的概率论知识点（建议复习）：离散&#x2F;连续型随机变量的分布，连续型随机变量的概率密度函数（PDF），数学期望</p>
<p>why：正常的定积分（黎曼积分）都要求有解析式才能够进行计算，而大多数情况解析式是求不出来的。蒙特卡洛积分提供了一种求解这些比较难以计算的积分的近似值的思路</p>
<p>what：在积分区域上随机采样，若采样方式为均匀采样（采样pdf为均匀分布），则认为样本和采样值的乘积 $xf(x)$ 为单次采样的积分结果，随后多次采样取平均，得到最终近似结果：<br>$$<br>F_N&#x3D;\frac{b-a}{N}\sum_{i&#x3D;1}^{N}{f(X_i)}<br>$$<br>可以借助之前黎曼积分的面积微元进行理解，蒙特卡洛积分就是求了一个面积的平均值</p>
<p>更一般的，若采样方式并非均匀，而是满足一种概率密度函数（pdf），则积分结果如下：<br>$$<br>F_N&#x3D;\frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{f(X_i)}{pdf(X_i)}\ ,\ (X_i\sim pdf(x))<br>$$<br>其中，N为采样次数，$X_i$为随机变量（采样值）</p>
<p>这里除以$pdf(X_i)$可以理解为一种加权，哪里采样的多哪里就多做平均</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPUGems3：</span><br><span class="line">...</span><br><span class="line">However, when we skew sample directions, not all estimates of the integral are equal, and thus we must weight them accordingly when averaging all the samples. For instance, one sample in a low-value region of the PDF is representative of what would be many samples if uniform sampling were used. Similarly, one sample in a high-value PDF region represents only a few samples with uniform sampling. To compensate for this property of the PDF-proportional sampling, we multiply each sample by the inverse of the PDF.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E5%AE%9A%E4%B9%89.png" alt="蒙特卡洛积分定义"></p>
<h3 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h3><p>Whitted-Style光线追踪的做法是，光线在镜面反射表面弹射，而在漫反射表面停止，这显然是不符合现实的</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/Whitted%EF%BC%9F(1).png" alt="Whitted？(1)"></p>
<p>其中一个问题，拿经典的Utah teaport为例，whitted光追只能做左图的光照效果，而对于那种有光泽但不全是镜面反射的glossy材质（右图），whitted做出来的效果并不尽如人意</p>
<p>第二个问题，whitted风格光线追踪不考虑漫反射，虽然递归的思想是正确的，但就像下图（康奈尔盒子）所示，whitted的天花板由于接收不到来自环境光照，呈现一个全黑的状态，并且whitted渲染出的长方体并没有表现红墙和绿墙上反射过来的带有色彩的光，相比之下，路径追踪的结果就真实很多</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/Whitted%EF%BC%9F(2).png" alt="Whitted？(2)"></p>
<h4 id="求解渲染方程"><a href="#求解渲染方程" class="headerlink" title="求解渲染方程"></a>求解渲染方程</h4><p>对于之前的渲染方程，我们可以用蒙特卡洛积分法进行求解</p>
<p>忽略自发光项（仅计算直接光照），简单考虑均匀采样的情况，半球立体角范围$[0,2\pi]$，因此$pdf(x)&#x3D;\frac{1}{2\pi}$<br>$$<br>L(p,\omega_{output})&#x3D;\int_{\Omega+}L(p,\omega_{input_i})·<br>f_r(p,\omega_{input_i}\rightarrow\omega_{output})·(n·\omega_{input_i})d\omega_{input_i}\<br>\approx\frac{1}{N}\sum_{i&#x3D;1}^{N}<br>\frac{L(p,\omega_{input_i})·f_r(p,\omega_{input_i}\rightarrow\omega_{output})·(n·\omega_{input_i})}{pdf(\omega_{input_i})}<br>$$<br>用伪代码表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shade(p,w_o)</span><br><span class="line">	Randomly choose N directions wi~pdf <span class="comment">//采样N个方向分别打光</span></span><br><span class="line">	Lo = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">for</span> each wi</span><br><span class="line">	&#123;</span><br><span class="line">		Trace a ray <span class="title function_">r</span><span class="params">(p,wi)</span>;</span><br><span class="line">		<span class="keyword">if</span> a ray hit the light <span class="comment">//若打到光源，则累加</span></span><br><span class="line">			Lo += (<span class="number">1</span>/N) * L_i * f_r * cosine / pdf(wi);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Lo;</span><br></pre></td></tr></table></figure>

<p>接着，引入间接光照</p>
<p>要知道着色点P因Q的反射获得多少能量，其实就相当于摄像机在P点处计算Q的直接光照</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E9%97%B4%E6%8E%A5%E5%85%89%E7%85%A7%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA.png" alt="间接光照路径追踪"></p>
<p>那么就只需要在上述伪代码中加一条判断，看看这条光线有没有打到其他物体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shade(p,w_o)</span><br><span class="line">	Randomly choose N directions wi~pdf <span class="comment">//采样N个方向分别打光</span></span><br><span class="line">	Lo = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">for</span> each wi</span><br><span class="line">	&#123;</span><br><span class="line">		Trace a ray <span class="title function_">r</span><span class="params">(p,wi)</span>;</span><br><span class="line">		<span class="keyword">if</span> ray r hit the light <span class="comment">//若打到光源，则累加</span></span><br><span class="line">			Lo += (<span class="number">1</span>/N) * L_i * f_r * cosine / pdf(wi);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ray r hit an object at q</span><br><span class="line">			Lo += (<span class="number">1</span>/N) * shade(q,-wi) * f_r * cosine / pdf(wi); <span class="comment">//若打到物体，则递归</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Lo;</span><br></pre></td></tr></table></figure>

<p>至此，基本的求解渲染方程已经有了大概的架构，但代码依然存在一些不可忽视的问题</p>
<h4 id="完善代码"><a href="#完善代码" class="headerlink" title="完善代码"></a>完善代码</h4><p>递归递归，有递有归，无非就是要考虑&#x3D;&#x3D;问题传递的可行性&#x3D;&#x3D;和&#x3D;&#x3D;有没有归&#x3D;&#x3D;这两方面因素</p>
<h5 id="问题传递的可行性"><a href="#问题传递的可行性" class="headerlink" title="问题传递的可行性"></a>问题传递的可行性</h5><p>p的着色需要q的环境光照信息，而q的环境光照信息又必须包含其他物体的环境光照信息，如此需要追踪的光线数量会呈指数级增长</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%981.png" alt="路径追踪递归问题1"></p>
<p>只有当采样数为1的时候，即N&#x3D;1时，才不会受到这种影响，路径追踪也因此得名（N$\neq$1时称为分布式光线追踪）</p>
<p>虽然但是，这样一来误差就会特别大，渲染结果势必会有非常多的噪点，为了解决这个问题，我们对单个像素计算多次路径追踪结果，随后求平均，这个过程其实也用到了蒙特卡洛方法</p>
<p>修改伪代码，得到路径追踪渲染方程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">shade(p,w_o)</span><br><span class="line">&#123;</span><br><span class="line">	Randomly choose One directions wi~pdf <span class="comment">//采样1个方向打光</span></span><br><span class="line">	Trace a ray <span class="title function_">r</span><span class="params">(p,wi)</span>;</span><br><span class="line">	<span class="keyword">if</span> ray r hit the light <span class="comment">//若打到光源，则累加</span></span><br><span class="line">		<span class="keyword">return</span> L_i * f_r * cosine / pdf(wi);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ray r hit an object at q</span><br><span class="line">		<span class="keyword">return</span> shade(q,-wi) * f_r * cosine / pdf(wi); <span class="comment">//若打到物体，则递归</span></span><br><span class="line">	<span class="keyword">return</span> Lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ray_generation(cam_pos,pixel)</span><br><span class="line">&#123;</span><br><span class="line">	Uniformly choose N sample positions within the pixel; <span class="comment">//对一个像素采样N个路径</span></span><br><span class="line">	<span class="comment">//对每条路径计算着色后进行累加，注意该处pdf和shade函数中的pdf并不相同，这里是对像素采样的pdf</span></span><br><span class="line">    <span class="keyword">for</span> each sample in the pixel</span><br><span class="line">	&#123;</span><br><span class="line">		shoot a ray <span class="title function_">r</span><span class="params">(cam_pos,cam2sample)</span>;</span><br><span class="line">		<span class="keyword">if</span> ray r hit the scene at p</span><br><span class="line">			pixel_radiance += <span class="number">1</span>/N * shade(p,sample2cam)/pdf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pixel_radiance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="递归结束条件"><a href="#递归结束条件" class="headerlink" title="递归结束条件"></a>递归结束条件</h5><p>很容易看出，上述算法的递归没有终止条件，放到现实中这也是非常合理的，因为现实中的光并不会弹射一定次数后终止弹射，而会一直弹射下去，在算法中强行设置终止次数结束递归不满足现实情况的能量守恒定律，会有一定亮度差异（弹射3次和弹射17次的亮度差异是非常明显的），为了解决这一问题，我们需要用到与俄罗斯轮盘赌类似的思想</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E4%BF%84%E7%BD%97%E6%96%AF%E8%BD%AE%E7%9B%98%E8%B5%8C.png" alt="俄罗斯轮盘赌"></p>
<p>这个思想其实就是一个伯努利分布（均匀分布）概念，让光线在每个弹射点都有一定概率继续弹射，设这个概率为p，那么光线停止弹射的概率为（1-p），为了得到相同的路径追踪结果，意味着这个伯努利实验的期望值必须保持Lo不变，那么我们可以巧妙的认为p概率继续弹射得到的能量是$\frac{Lo}{p}$（终止弹射的结果很自然就是0）<br>$$<br>E&#x3D;P·\frac{Lo}{P}+(1-p)·0&#x3D;Lo<br>$$<br>总结到伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">shade(p,w_o)</span><br><span class="line">&#123;</span><br><span class="line">	Manually specify a probability P_RR；</span><br><span class="line">	Randomly select ksi in a uniform dist. in [<span class="number">0</span>,<span class="number">1</span>]； <span class="comment">//取0-1的一个随机数</span></span><br><span class="line">	<span class="keyword">if</span> (ksi &gt; P_RR)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">		</span><br><span class="line">	Randomly choose One directions wi~pdf <span class="comment">//采样1个方向打光</span></span><br><span class="line">	Trace a ray <span class="title function_">r</span><span class="params">(p,wi)</span>;</span><br><span class="line">	<span class="keyword">if</span> ray r hit the light</span><br><span class="line">		<span class="keyword">return</span> L_i * f_r * cosine / pdf(wi) / P_RR;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ray r hit an object at q</span><br><span class="line">		<span class="keyword">return</span> shade(q,-wi) * f_r * cosine / pdf(wi) / P_RR;</span><br><span class="line">	<span class="keyword">return</span> Lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，我们就有了一个合理的递归终止条件</p>
<p><em>思考：闫老师上课提了一个问题，对于分布式光线追踪，这个期望值是多少</em></p>
<p><em>答：$E&#x3D;\frac{p}{(1-p)^2}$，证明如下</em><br>$$<br>\sum_{n&#x3D;1}^\infty np^n&#x3D;p+2p^2+3p^3+···+np^n ①\<br>p\sum_{n&#x3D;1}^\infty np^n&#x3D;p^2+2p^3+···+(n-1)p^n+np^{n+1} ②\<br>①-②:(1-p)\sum_{n&#x3D;1}^\infty np^n&#x3D;p+p^2+p^3+···+p^n-np^{n+1}&#x3D;\sum_{n&#x3D;1}^\infty p^n&#x3D;\frac{p}{1-p}\<br>E&#x3D;\sum_{n&#x3D;1}^\infty np^n&#x3D;\frac{p}{(1-p)^2}<br>$$</p>
<h4 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h4><p>至此，我们的路径追踪算法已经做到完全正确，但又出现了一个矛盾点，即像素的采样率</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E5%83%8F%E7%B4%A0%E9%87%87%E6%A0%B7%E7%8E%87%E5%B7%AE%E5%BC%82.png" alt="像素采样率差异"></p>
<p>上左图为采样率较低的情况，渲染速度快，效果差，右图采样率较高，效果好，但渲染速度慢</p>
<p>引发这个矛盾的原因是光源大小的不确定性，我们的算法在计算间接光照的时候，可能在采样路径半当中还没弹射到光源就被俄罗斯轮盘终止掉了，相当于这次计算算了个寂寞。面对大的光源，这种情况会很少，而一旦碰上了小光源，这种浪费现象会频繁发生，这是我们不希望看到的，所以我们就想能不能不用这种基于着色点采样的方式，而改为一种基于光源的pdf</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9D%87%E5%8C%80%E9%87%87%E6%A0%B7%E7%9A%84%E7%BC%BA%E7%82%B9.png" alt="路径追踪均匀采样的缺点"></p>
<p>先不考虑光源和着色点之间有物体阻挡这种情况，把光源视为一个矩形表面，直接在光源上采样，就不会发生这种浪费</p>
<p>设着色点法线为n，光源平面的法线n’，如图</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E5%AF%B9%E5%85%89%E6%BA%90%E8%BF%9B%E8%A1%8C%E9%87%87%E6%A0%B7.png" alt="对光源进行采样"></p>
<p>设光源平面面积为A，采样面积dA，则对光源均匀采样的pdf为$\frac{1}{A}$（原因见上图ppt），问题是，之前提渲染方程的时候，都是采样到哪个点就计算哪个点的立体角的积分，这里在光源上采样，却还用着着色点的立体角微分，这显然是不对的</p>
<p>因此，我们需要对积分域做一个变换，即找到$d\omega$和$dA$的关系</p>
<p>先算$dA·cos\theta’$求出$dA$在$d\omega$上的投影，再通过立体角定义，求得<br>$$<br>d\omega&#x3D;\frac{dAcos\theta’}{|x’-x|^2}<br>$$<br>重写渲染方程<br>$$<br>L(p,\omega_{output})&#x3D;\int_{\Omega+}L(p,\omega_{input_i})·<br>f_r(p,\omega_{input_i}\rightarrow\omega_{output})·cos\theta \ d\omega_{input_i}\<br>&#x3D;\int_{\Omega+}L(p,\omega_{input_i})·<br>f_r(p,\omega_{input_i}\rightarrow\omega_{output})·\frac{cos\theta ·cos\theta’}{|x’-x|^2} \ dA<br>$$</p>
<p>之前对着色点采样，是一条路径上每弹射一次就判断一次是否继续递归，对于光源采样，思路要进行微调，即分为两部分计算，一部分是光源直接对着色点的影响，另一部分是光源的间接影响</p>
<p>翻译到伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shade(p,wo)</span><br><span class="line">&#123;at x<span class="number">&#x27;</span>;	<span class="comment">//pdf_light = 1/A</span></span><br><span class="line">    L_dir = L_i * f_r * <span class="built_in">cos</span>θ * <span class="built_in">cos</span>θ<span class="string">&#x27; / |x&#x27;</span>-p|^<span class="number">2</span> / pdf_light;</span><br><span class="line"></span><br><span class="line">	# Contribution from other reflectors</span><br><span class="line">	L_indir = <span class="number">0.0</span>;</span><br><span class="line">	Test Russian Roulette with probability P_RR;</span><br><span class="line">    Uniformly sample the hemisphere toward wi;	<span class="comment">//pdf_hemi = 1 / 2pi</span></span><br><span class="line">    Trace a ray <span class="title function_">r</span><span class="params">(p,wi)</span>;</span><br><span class="line">    <span class="keyword">if</span> ray r hit a non-emitting object at q</span><br><span class="line">        L_indir = shade(q,-wi) * f_r * <span class="built_in">cos</span>θ / pdf_hemi / P_RR;</span><br><span class="line">    <span class="keyword">return</span> L_dir + L_indir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还没完，回到没考虑的光源和着色点之间有物体阻挡的情况，需要额外再加一个判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shade(p,wo)</span><br><span class="line">&#123;</span><br><span class="line">	# Contribution from the light source.</span><br><span class="line">    Uniformly sample the light at x<span class="number">&#x27;</span>;	<span class="comment">//pdf_light = 1/A</span></span><br><span class="line">    Shoot a ray from p to x<span class="number">&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> the ray is not blocked in the middle</span><br><span class="line">    	L_dir = ...</span><br><span class="line">    ...</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>总结一下路径追踪的整体思路：由像素采样打出追踪路径确定需要计算的着色点，再光源采样计算每个着色点的着色信息，返回给像素</p>
<p>看下结果</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E7%BB%93%E6%9E%9C%E5%87%A0%E4%B9%8E100%25%E6%AD%A3%E7%A1%AE.png" alt="路径追踪结果几乎100%正确"></p>
<p>可以看到，路径追踪几乎可以做到100%正确</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现代的光线追踪已经不再仅仅是指Whitted风格光线追踪了，Ray-Tracing可以被理解为一切模拟光线传播的方法的集合，如双向路径追踪，光子映射等等等等。计图是一个很深的坑，一门入门课肯定有很多东西覆盖不到，就拿路径追踪来说——</p>
<p>蒙特卡洛积分应该用什么pdf？（重要性采样）</p>
<p>计算机自带的随机数真的正确么？（随机数质量）</p>
<p>对着色点采样和对光源采样二者能否结合？（多重重要性采样 IMS）</p>
<p>对像素的采样需要如何加权？</p>
<p>最后得到的结果是radiance，如何转化为像素颜色？（伽马矫正）</p>
<p>……</p>
<p>路径追踪仍然是入门级别的内容……敬畏科学吧</p>
<h2 id="七、材质和外观"><a href="#七、材质和外观" class="headerlink" title="七、材质和外观"></a>七、材质和外观</h2><p>之前我们为了描述单位受照面吸收能量后辐射出去的Radiance分布情况，引入了BRDF函数，这个函数表示了材质如何与光线作用</p>
<p>而之后我们研究物体的材质和外观，就是在研究这些函数</p>
<h3 id="漫反射材质"><a href="#漫反射材质" class="headerlink" title="漫反射材质"></a>漫反射材质</h3><p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8.png" alt="漫反射材质"></p>
<p>在Blinn-Phong模型中，讨论漫反射系数的时候，我们只是经验性的引入$\frac{I}{r^2}$来表示到达着色点的能量<br>$$<br>L_d&#x3D;k_d(\frac{I}{r^2})max(0,n·l)<br>$$<br>在学完渲染方程后，我们知道这其实并不准确，现在用$f_r$来准确计算这个漫反射系数</p>
<p>假设任意方向的入射光和出射光的Radiance和Irradiance都相等，着色点不吸收任何能量，且自发光项为0</p>
<p>则依渲染方程，可推出$f_r$如下<br>$$<br>L_o&#x3D;\int_{\Omega^+} L_i \cdot f_r \cdot cos\theta_i, \mathrm{d}\omega_i<br>&#x3D;L_i \cdot f_r\int_{\Omega^+} cos\theta_i , \mathrm{d}\omega_i\</p>
<p>\int_{\Omega^+} cos\theta_i, \mathrm{d}\omega_i<br>&#x3D;\int_{\Omega^+} cos\theta_i \ sin\theta_i , \mathrm{d}\theta_i , \mathrm{d}\phi_i<br>&#x3D;\int_0^{2\pi}\int_0^{\frac{\pi}{2}}sin\theta_i , \mathrm{d}\sin\theta_i \ , \mathrm{d}\phi_i&#x3D; \pi\</p>
<p>L_o&#x3D;f_rL_i\pi\Longrightarrow f_r&#x3D;\frac{L_o}{L_i \pi}&#x3D;\frac{1}{\pi}\<br>$$<br>定义一个反射率（albedo）$\rho\in[0,1]$与$f_r$相乘，于是通过$f_r$就可以控制材质的颜色变化<br>$$<br>f_r&#x3D;\frac{\rho}{\pi}\in[0,\frac{1}{\pi}]<br>$$</p>
<h3 id="光泽材质"><a href="#光泽材质" class="headerlink" title="光泽材质"></a>光泽材质</h3><p>光泽材质是介于漫反射材质与理想镜面反射材质之间的一种材质，光线的反射方向集中在一个小范围内</p>
<p>生活中的光泽材质有如打磨过的铜镜或者其他的一些金属材质</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%85%89%E6%B3%BD%E6%9D%90%E8%B4%A8.png" alt="光泽材质"></p>
<h3 id="理想反射-折射材质"><a href="#理想反射-折射材质" class="headerlink" title="理想反射&#x2F;折射材质"></a>理想反射&#x2F;折射材质</h3><p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E7%90%86%E6%83%B3%E5%8F%8D%E5%B0%84%E6%8A%98%E5%B0%84%E6%9D%90%E8%B4%A8.png" alt="理想反射折射材质"></p>
<p>光线到达材质表面被吸收一部分，同时发生镜面反射和镜面折射，这种材质被称为Ideal reflective &#x2F; refractive material</p>
<h4 id="（完美）镜面反射"><a href="#（完美）镜面反射" class="headerlink" title="（完美）镜面反射"></a>（完美）镜面反射</h4><p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%AE%8C%E7%BE%8E%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84.png" alt="完美镜面反射"></p>
<p>公式分为两部分，左图（正视图）观察入射角和出射角，右图（俯视图）观察方位角</p>
<p>写出正确的完美镜面反射BRDF方程需要用到δ函数，在此从略</p>
<p>δ函数：<a target="_blank" rel="noopener" href="https://wuli.wiki/online/Delta.html#note2">https://wuli.wiki/online/Delta.html#note2</a></p>
<h4 id="镜面折射"><a href="#镜面折射" class="headerlink" title="镜面折射"></a>镜面折射</h4><p>光从一种透明介质斜射入另一种透明介质时，由于光在两种介质中传播速度不同而使传播方向发生偏转的现象称为折射（初中物理）</p>
<p>生活中的折射现象有如：</p>
<p>三棱镜色散（不同波长的色光有不同的折射率）（依然用几何光学描述，不涉及波粒二象性等内容）</p>
<p>海水焦散，Caustics（不合适的翻译，主要还是由折射后聚焦引发，与散射关系不大）</p>
<h5 id="斯涅耳定律"><a href="#斯涅耳定律" class="headerlink" title="斯涅耳定律"></a>斯涅耳定律</h5><p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E6%96%AF%E6%B6%85%E8%80%B3%E5%AE%9A%E5%BE%8B.png" alt="斯涅耳定律"></p>
<p>入射材质折射率 × 入射角正弦 &#x3D; 出射材质折射率 × 折射角正弦</p>
<p>由图右侧常见折射率，钻石折射率较大，这就意味着光线通过钻石发生的偏转幅度比较大，这也是为什么钻石闪闪发光的原因</p>
<p>进一步推导</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E6%8A%98%E5%B0%84%E5%AE%9A%E5%BE%8B.png" alt="折射定律"></p>
<p>我们发现，折射的发生条件是入射材质的折射率小于出射材质折射率，一旦大于，就会发生全反射现象</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E6%96%AF%E6%B6%85%E8%80%B3%E7%AA%97.png" alt="斯涅耳窗"></p>
<p>人在水底只能看到锥形视野范围内的光，也是因为折射，相关现象被称为斯涅耳窗（snell’s window）</p>
<h4 id="双向散射分布函数（BSDF）"><a href="#双向散射分布函数（BSDF）" class="headerlink" title="双向散射分布函数（BSDF）"></a>双向散射分布函数（BSDF）</h4><p>描述反射的分布函数被称为双向反射分布函数（BRDF），那么描述折射也需要一种分布函数</p>
<p>这种分布函数被称为双向折射(透射)分布函数（BTDF）</p>
<p>BRDF和BTDF统称为双向散射分布函数（BSDF）<br>$$<br>f_s&#x3D;f_r+f_t<br>$$</p>
<h4 id="菲涅尔项"><a href="#菲涅尔项" class="headerlink" title="菲涅尔项"></a>菲涅尔项</h4><p>观察下图中视角与反射结果的关系</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E8%8F%B2%E6%B6%85%E5%B0%94%E5%8F%8D%E5%B0%84%E4%BE%8B%E5%AD%90.png" alt="菲涅尔反射例子"></p>
<p>我们很容易发现，当我们用几乎垂直的视角看下去，基本看不到什么反射，而当我们的视角几乎水平时，反射结果特别明显</p>
<p>这是因为光线以不同角度入射会有不同的反射率，也就是所谓的菲涅尔效应</p>
<p>生活中的菲涅尔效应还有例如：</p>
<p>正对着窗子看能看清窗外景色，侧着看窗外看到大多室内的反射</p>
<p>站在湖边，透过近处的湖水能看见水底的情况，而望向远处只能看到群山的倒影</p>
<p>……</p>
<p>另外，在相同的入射角情况下，不同的材质也具有不同的反射率，即具有不同的菲涅尔项</p>
<p>下图即为两种不同的材质对应的菲涅尔项数据</p>
<table>
<thead>
<tr>
<th align="center">折射率为1.5的绝缘体</th>
<th align="center">导体</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E8%8F%B2%E6%B6%85%E5%B0%94%E9%A1%B91.png" alt="菲涅尔项1"></td>
<td align="center"><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E8%8F%B2%E6%B6%85%E5%B0%94%E9%A1%B92.png" alt="菲涅尔项2"></td>
</tr>
</tbody></table>
<p>图中另外两条虚线表示光的极化性质，即光只沿一个方向振动情况下的菲涅尔项，现在的渲染器很少考虑这种情况</p>
<p>由图对应到现实一目了然，生活中各种金属的反射率一直都很高，所以我们习惯用镀银的玻璃作为镜子而不是用玻璃…</p>
<p>为了计算菲涅尔项，有非常复杂的公式，通过极化的菲涅尔数据做平均得到结果</p>
<p>但我们也有简单的近似（施利克近似 Schlick’s approximation），如图</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E8%AE%A1%E7%AE%97%E8%8F%B2%E6%B6%85%E5%B0%94%E9%A1%B9.png" alt="计算菲涅尔项"></p>
<p>这种近似方法认为菲涅尔曲线就是一条从  0°入射角菲涅尔项到90°入射角  的单调增函数，90°时$R_0&#x3D;1$</p>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/303168568">光的反射与折射——从Snell、Fresnel到Schlick - 知乎 (zhihu.com)</a></p>
<h3 id="微表面模型"><a href="#微表面模型" class="headerlink" title="微表面模型"></a>微表面模型</h3><p>从理论上来说，地球表面是凹凸不平的，具有沙漠山丘等复杂地形，但在非常远的距离下拍摄，如下图所示的卫星图，我们却看到了如同在光滑球面上一样的高光</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%8D%AB%E6%98%9F%E5%9B%BE.png" alt="卫星图"></p>
<p>由此我们提出微表面模型，假设离得足够远的时候，微观表面可以被忽略，而最后看到一个宏观的结果</p>
<p>用微表面理论解释漫反射，即从微观看漫反射表面，每个微元表面都是完美镜面反射，都有各自的法线（微观上看是几何）</p>
<p>我们可以通过研究这些法线的分布来描述物体表面的粗糙程度</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%BE%AE%E8%A1%A8%E9%9D%A2%E6%B3%95%E7%BA%BF%E5%88%86%E5%B8%83.png" alt="微表面法线分布"></p>
<p>镜面反射的法线方向分布比较集中，而漫反射表面的法线分布比较分散</p>
<p>有了微表面模型，我们就可以提出在微表面下的更精确的BRDF方程</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%BE%AE%E8%A1%A8%E9%9D%A2%E6%A8%A1%E5%9E%8BBRDF.png" alt="微表面模型BRDF"></p>
<p>如图，F为菲涅尔项；D为法线分布，查询半程向量是否在法线分布内；G为几何项，由于在微表面上，对于那些几乎和表面平行的入射光，很容易发生互相遮挡的现象，从而使得部分微表面失去作用，我们把这种光线角度称为掠射角度（Grazing Angle），在这种角度下的着色会非常亮，G项就起到了一定的修正作用<br>$$<br>NDF_{GGTR}(n, h, \alpha) &#x3D; \frac{\alpha^2}{\pi((n \cdot h)^2 (\alpha^2 - 1) + 1)^2}\<br>G_{SchlickGGX}(n, v, k) &#x3D; \frac{n \cdot v} {(n \cdot v)(1 - k) + k },\ (k_{direct} &#x3D; \frac{(\alpha + 1)^2}{8},\ k_{IBL} &#x3D; \frac{\alpha^2}{2})\<br>G(n, v, l, k) &#x3D; G_{sub}(n, v, k) G_{sub}(n, l, k)\<br>F_{Schlick}(h, v, F_0) &#x3D; F_0 + (1 - F_0) ( 1 - (h \cdot v))^5 \<br>L_o(p,\omega_o) &#x3D; \int\limits_{\Omega} (k_d\frac{c}{\pi} + \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}) L_i(p,\omega_i) n \cdot \omega_i \mathrm{d}\omega_i<br>$$</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%BE%AE%E8%A1%A8%E9%9D%A2%20(2).png" alt="微表面 (2)"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%BE%AE%E8%A1%A8%E9%9D%A2%20(3).png" alt="微表面 (3)"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%BE%AE%E8%A1%A8%E9%9D%A2%20(1).png" alt="微表面 (1)"></th>
</tr>
</thead>
</table>
<p>微表面模型可以得到非常真实的渲染结果，因为他本身就是基于物理的渲染（PBR&#x2F;PBS）</p>
<p>当然，微表面也有他的缺点，有时因为diffuse的太少，需要手动往上加点参数调节</p>
<h3 id="各向同性-各向异性材质"><a href="#各向同性-各向异性材质" class="headerlink" title="各向同性&#x2F;各向异性材质"></a>各向同性&#x2F;各向异性材质</h3><p>各向同性（IsotropicMaterials）：微表面不存在方向性<br>各向异性（Anisotropic Materials）：微表面存在方向性</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%90%84%E5%90%91%E5%90%8C%E6%80%A7%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7.png" alt="各向同性各向异性"></p>
<p>对于BRDF来说，这里所说的方向性就是指，如果入射光和出射光做一定方位角的旋转前后，BRDF方程不变，那么这种材质就是各向同性的，反之则为各向异性</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7.png" alt="各向异性"></p>
<p>再看几个各向异性的例子</p>
<table>
<thead>
<tr>
<th align="center">不锈钢</th>
<th align="center">尼龙</th>
<th align="center">天鹅绒</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E4%BE%8B1.png" alt="各向异性例1"></td>
<td align="center"><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E4%BE%8B2.png" alt="各向异性例2"></td>
<td align="center"><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E4%BE%8B3.png" alt="各向异性例3"></td>
</tr>
</tbody></table>
<h3 id="BRDF性质总结"><a href="#BRDF性质总结" class="headerlink" title="BRDF性质总结"></a>BRDF性质总结</h3><ul>
<li>非负性：描述能量分布</li>
<li>线性性：可以被拆分成不同项的线性组合（ambient，diffuse，specular）</li>
</ul>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/BRDF%E9%9D%9E%E8%B4%9F%E6%80%A7%E7%BA%BF%E6%80%A7%E6%80%A7.png" alt="BRDF非负性线性性"></p>
<ul>
<li>可逆性：调换入射出射方向，BRDF渲染结果严格不变</li>
<li>能量守恒：出射光线的能量永远不能超过入射光线的能量</li>
</ul>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/BRDF%E5%8F%AF%E9%80%86%E6%80%A7%E8%83%BD%E9%87%8F%E5%AE%88%E6%81%92.png" alt="BRDF可逆性能量守恒"></p>
<ul>
<li>各向同&#x2F;异性：如果是各项同性材质，则BRDF值只和相对方位角有关，四维的BRDF材质可以被降维为三维，并且根据可逆性，结果不需要考虑方位角的正负</li>
</ul>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/BRDF%E5%90%84%E9%A1%B9%E5%90%8C%E6%80%A7.png" alt="BRDF各项同性"></p>
<h3 id="BRDF的测量"><a href="#BRDF的测量" class="headerlink" title="BRDF的测量"></a>BRDF的测量</h3><p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E7%90%86%E8%AE%BAor%E5%AE%9E%E9%99%85.png" alt="理论or实际"></p>
<p>如图，推算出来的菲涅尔项和实际测量出来的往往会有很大差距，跟不用说BRDF了</p>
<p>如果工业上能直接测量材质的BRDF，就不需要如此复杂的理论推导而能直接使用数据了</p>
<p>测量BRDF的大致过程如下图所示</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E6%B5%8B%E9%87%8FBRDF%E5%A4%A7%E8%87%B4%E5%8E%9F%E7%90%86.png" alt="测量BRDF大致原理"></p>
<p>给定一个着色点，通过改变入射和出射的角度（改变光源与相机位置）进行测量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foreach outgoing direction wo</span><br><span class="line">	move light to illuminate surface with a thin beam from wo</span><br><span class="line">	for each incoming direction wi</span><br><span class="line">		move sensor to be at direction wi from surface</span><br><span class="line">		measure incident radiance</span><br></pre></td></tr></table></figure>

<p>如算法伪代码所示，这样测出来的BRDF是四维的，这样的测量是非常费时的</p>
<p>为了提高效率，我们可以尽量让材质呈各向同性</p>
<p>就像之前说的，这不仅可以让BRDF从四维降至三维，还能由光路可逆性再砍去一半的测量</p>
<p>最后，关于BRDF的储存，有一个著名的库 <code> MERL BRDF Database</code>，是三菱电子实验室和MIT合作的项目，不做细说</p>
<h2 id="八、渲染前沿话题"><a href="#八、渲染前沿话题" class="headerlink" title="八、渲染前沿话题"></a>八、渲染前沿话题</h2><p>多图预警</p>
<h3 id="高级光线传播方式"><a href="#高级光线传播方式" class="headerlink" title="高级光线传播方式"></a>高级光线传播方式</h3><p>首先需要引入数理统计中关于有偏和无偏的概念</p>
<p>什么是无偏估计：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22983179">https://www.zhihu.com/question/22983179</a></p>
<p>之前提到的蒙特卡洛方法是一种光线追踪中常用的估计方法，具体来说，是在求解渲染方程时，以特定的pdf分布对被积函数进行采样，再用采样到的样本来估计积分值的一种方法，但那时我们并没有提及什么样的pdf采样是最好的，这就涉及有偏和无偏的概念</p>
<p>如果样本得到的期望值与总体的期望值相等，那么这种估计就被称为无偏的，反之则有偏</p>
<p>除了无偏性，还有两种判断估计的准确性的评判标准——有效性和一致性（相合性）</p>
<p>暂且不提有效性，如果采样的样本数量趋近于无穷时，样本统计量的期望收敛于总体统计量的期望，则称这种估计是一致的</p>
<p>有了以上统计学概念，再继续分类来看现代图形学的几种高级光线传播方式</p>
<h4 id="无偏光线传播方法"><a href="#无偏光线传播方法" class="headerlink" title="无偏光线传播方法"></a>无偏光线传播方法</h4><h5 id="双向路径追踪（BDPT）"><a href="#双向路径追踪（BDPT）" class="headerlink" title="双向路径追踪（BDPT）"></a>双向路径追踪（BDPT）</h5><p>之前所说的路径追踪利用了光路可逆性，通过形成相机到光源的&#x3D;&#x3D;单向路径&#x3D;&#x3D;来计算光照结果</p>
<p>而双向路径追踪，顾名思义，就是从光源和相机分别打出一些半路径，最后连接两条半路径的端点，形成整条路径</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/BDPT%E5%8E%9F%E7%90%86.png" alt="BDPT原理"></p>
<p>请注意，BDPT的原理看起来很简单，但实际实现起来非常困难（如果能实现，那么独立写渲染器也应该不在话下了）</p>
<p>这种方法适用于那些光线传播在光源一侧比较好计算的情况</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/BDPT%E6%95%88%E6%9E%9C.png" alt="BDPT效果"></p>
<p>就如上图所示，整个场景的光源只有左上角的聚光灯和右侧打向左侧的聚光灯，其余部分都由环境光照照亮，这就意味着使用传统路径追踪打出的路径的第一个弹射点大概率是漫反射表面，反射路径弹向光源的概率小，没弹几次就被俄罗斯轮盘终止了，这就会很难计算到光源的信息，从而形成大量噪点。为了解决这个问题，从光源采样是一个优化方法，而BDPT则是另一个更高级的解决方案，从图中可以看出，双向路径追踪的效果是非常好的</p>
<h5 id="Metropolis光线传播"><a href="#Metropolis光线传播" class="headerlink" title="Metropolis光线传播"></a>Metropolis光线传播</h5><p>Metropolis光线传播方法主要利用了马尔科夫链做蒙特卡洛估计（Markov Chain Monte Carlo，MCMC，马尔科夫链蒙特卡洛法），这种估计方法与之前介绍的蒙特卡洛方法的主要区别在于采样方式，之前在对像素多重采样的时候，我们所用的蒙特卡洛估计都是均匀采样，而马尔科夫链通俗来讲就是在已采样样本附近生成一个新样本继续做后续估计，每个样本之间不再独立，也就是说每次对当前像素的采样都基于上次对该像素的采样，这种采样方法得到的pdf可以与被积函数形状保持基本一致，采样的效果也就比均匀采样更好</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/MLT%E5%8E%9F%E7%90%86.png" alt="MLT原理"></p>
<p>上图所示原理，即在已有路径（蓝）基础上加以扰动，得到新光路（橙）</p>
<p>注意这里是对像素采样，而不是在解渲染方程</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/MLT%E6%95%88%E6%9E%9C.png" alt="MLT效果"></p>
<p>从图中也明显可以看出MLT的强大</p>
<p>这种方法尤其适用于复杂的光线传播情况，如半掩着门的房间，或者发生焦散的水体（SDS路径，specular→diffuse→specular）等，因为这些复杂的光线传播一旦找到一条路径，就可以不断在周围找到更多的路径，从而达到以更快速度获得更高质量渲染结果的目的</p>
<p>但是，这不代表这种方法没有它的局限</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/MLT%E7%BC%BA%E7%82%B9.png" alt="MLT缺点"></p>
<p>用了这种算法之后，对于每个像素来说，其渲染时间是很难从理论上计算出来的，也就很难用来去渲染动画，并且，因为他所有的操作过程都是局部的，每个像素渲染时收敛所需的时间都不一样，这就导致图片看上去比较脏（图中砖缝尤为明显）</p>
<h4 id="有偏光线传播方法"><a href="#有偏光线传播方法" class="headerlink" title="有偏光线传播方法"></a>有偏光线传播方法</h4><h5 id="光子映射（Photon-Mapping）"><a href="#光子映射（Photon-Mapping）" class="headerlink" title="光子映射（Photon Mapping）"></a>光子映射（Photon Mapping）</h5><p>光源打出光线的过程可以被理解为不断打出光子的过程，光子映射（PM）就利用了这一想法</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/PM%E5%8E%9F%E7%90%86.png" alt="PM原理"></p>
<p>整个过程分为两步</p>
<ul>
<li>先从光源出发打出光子，让其在空间内传播散射，直到打到漫反射表面为止</li>
<li>然后再从摄像机打出路径，进行着色计算，着色点的亮度取决于光子的密度</li>
</ul>
<p>具体做法是对每个着色点，取其附近的N个光子，做密度估计（树状结构实现算法），$\rho&#x3D;\frac{N}{A}$</p>
<p>A可以由球形包围盒与表面求交得到（方法不唯一）</p>
<p>但这又有一个问题，我们直接来看效果</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/PM%E6%95%88%E6%9E%9C.png" alt="PM效果"></p>
<p>很容易发现，在做密度估计的时候，N小了噪声会非常大，N大了图像又会变得模糊</p>
<p>这是因为光子映射本身就是一个有偏的方法，算密度应该用$\frac{N}{dA}$，而我们的密度估计时用的是$\triangle A$，$\frac{N}{dA}\neq\triangle A$，只有$\triangle A$足够小才能做到正确估计，否则多少会有点糊</p>
<p>为了让$dA$足够小，可以在一开始发射光子的时候就多发射点，提高采样数，那么同样多的N对应的$dA$就会相对小，也就是说，这种方法虽然有偏，但他是一致的</p>
<p>那么为什么不能取固定的$\triangle A$来数里面的N呢？因为这样一来$\triangle A$就锁死了，永远不会靠近$dA$，采样多，$\triangle A$里的N确实是会变多，但那也只是结果变亮而已，换句话说这样的结果是有偏且不一致的，因此我们通常采用前一种方法</p>
<h5 id="顶点连接-合并（VCM）"><a href="#顶点连接-合并（VCM）" class="headerlink" title="顶点连接&#x2F;合并（VCM）"></a>顶点连接&#x2F;合并（VCM）</h5><p>VCM（Vertex connection and merging）就是把双向路径追踪和光子映射结合起来的一种方法</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/VCM.png" alt="VCM"></p>
<p>双向路径追踪会发生两条子路径端点非常接近的情况（在同一个局部面积内），这时候BDPT就认为这种路径无效，就是一种浪费</p>
<p>对于这种情况，VCM就认为其中一条路径打过来的不是光线而是光子，用光子映射的方法把两条路径的贡献结合起来，避免了这种浪费</p>
<p>现实在电影行业以及许多实践中，也确实使用了VCM这种方法</p>
<h4 id="实时辐射度（Instant-Radiosity）"><a href="#实时辐射度（Instant-Radiosity）" class="headerlink" title="实时辐射度（Instant Radiosity）"></a>实时辐射度（Instant Radiosity）</h4><p>有时候也被称为“很多光源的算法”(VPL &#x2F; many light methods)，核心思想是将每个被照亮的表面都作为虚拟的点光源来看待，再具体点，这种算法是把光源打出的光线所打到的地方作为二级光源，计算着色时遍历这些二级光源叠加计算</p>
<p>优点：速度快，在漫反射场景中效果很好</p>
<p>缺点：当虚拟光源离着色点特别近的时候，会出现反常亮点，类似漏光的现象，这和之前路径追踪对光源采样的距离平方项有关；另外，这种方法无法处理光泽材质</p>
<h3 id="高级外观建模方法"><a href="#高级外观建模方法" class="headerlink" title="高级外观建模方法"></a>高级外观建模方法</h3><h4 id="非表面模型"><a href="#非表面模型" class="headerlink" title="非表面模型"></a>非表面模型</h4><h5 id="散射介质"><a href="#散射介质" class="headerlink" title="散射介质"></a>散射介质</h5><p>光线进入散射介质会发生两件事——被吸收或者散射</p>
<p>光线走多远被吸收，由介质的吸收能力决定；光线以何种方式散射，由介质的相位函数决定</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E7%9B%B8%E4%BD%8D%E5%87%BD%E6%95%B0.png" alt="相位函数"></p>
<p>渲染方法：直线传播 -&gt; 散射 -&gt; 直线传播 -&gt; 散射 -&gt;  直线传播  -&gt;  … -&gt;  吸收</p>
<p>对每个发生散射的着色点，与光源连接，计算路径的贡献</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E6%95%A3%E5%B0%84%E4%BB%8B%E8%B4%A8%E6%B8%B2%E6%9F%93.png" alt="散射介质渲染"></p>
<p>电影《超能陆战队》中旧京山（San Fransokyo，三藩京，虚构城市）场景的雾效就应用了散射介质</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Big%20Hero.png" alt="Big Hero"></p>
<h5 id="头发-毛发"><a href="#头发-毛发" class="headerlink" title="头发&#x2F;毛发"></a>头发&#x2F;毛发</h5><p>先来看一个简单的模型</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Kajiya%20Kay.png" alt="Kajiya Kay"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Kajiya%20Kay%E6%95%88%E6%9E%9C.png" alt="Kajiya Kay效果"></th>
</tr>
</thead>
</table>
<p>首先，Kajiya-Kay模型将头发丝看做一个可弯曲的圆柱，这也是之后所有其他方法的基础</p>
<p>然后该模型认为，光线打到头发上会呈圆锥状散射（类似specular），同时又会被散射到四面八方（类似diffuse）</p>
<p>可以看到，这种diffuse+specular 的模拟效果并不尽如人意，但值得肯定的是，Kajiya-Kay模型为后续模型的提出奠定了基础</p>
<p>后来提出的Marschner模型，在Kajiya-Kay模型基础上，得到了广泛应用</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Marschner.png" alt="Marschner"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Marschner%E6%95%88%E6%9E%9C.png" alt="Marschner效果"></th>
</tr>
</thead>
</table>
<p>这个模型不再简单将头发丝视为圆柱，而是更进一步认为“圆柱”由“角质层”和“皮质层”组成</p>
<p>而光线的作用过程也更加复杂，总共分为三类：</p>
<ul>
<li>T：直接反射</li>
<li>TT：穿进“皮质层”，再从“角质层”穿出</li>
<li>TRT：穿进“皮质层”，在内部反射，再从“角质层”穿出</li>
</ul>
<table>
<thead>
<tr>
<th align="center">T</th>
<th align="center">TT</th>
<th align="center">TRT</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Marschner%20(2).png" alt="Marschner (2)"></td>
<td align="center"><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Marschner%20(1).png" alt="Marschner (1)"></td>
<td align="center"><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Marschner%20(3).png" alt="Marschner (3)"></td>
</tr>
</tbody></table>
<p>可以看到效果还是非常不错的</p>
<p>以上模型都是对人类头发来说的，那么更进一步，应用到动物毛发效果如何？</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%8A%A8%E7%89%A9%E6%AF%9B%E5%8F%91.png" alt="动物毛发"></p>
<p>明显不一样，显然右图更接近真实我们想要的效果</p>
<p>下面从生物学角度深入探讨人类动物毛发的结构区别</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%8A%A8%E7%89%A9%E6%AF%9B%E5%8F%91%E7%94%9F%E7%89%A9%E5%AD%A6%E7%BB%93%E6%9E%841.png" alt="动物毛发生物学结构1"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%8A%A8%E7%89%A9%E6%AF%9B%E5%8F%91%E7%94%9F%E7%89%A9%E5%AD%A6%E7%BB%93%E6%9E%842.png" alt="动物毛发生物学结构2"></th>
</tr>
</thead>
</table>
<p>除了角质和皮质，毛发还具有髓质结构，并且动物毛发的髓质明显比人类毛发的髓质粗不少</p>
<p>于是我们的闫令琪老师就提出了一种双层圆柱模型来模拟这种情况</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/double%20cylinder.png" alt="double cylinder"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/double%20cylinder%E6%95%88%E6%9E%9C.png" alt="double cylinder效果"></th>
</tr>
</thead>
</table>
<p>该模型在Marschner模型的T，TT，TRT基础上又加了两个计算项：TTs和TRTs</p>
<ul>
<li>TTs：TT传进“皮质层”时打到髓质发生散射，再从“角质层”穿出</li>
<li>TRTs：TRT进入“皮质层”时发生发射，来回打到两次髓质，最后从“角质层”穿出</li>
</ul>
<p>可以看到，髓质对毛发色彩表现的影响还是非常大的，相关理论已被应用到《狮子王》《猩球崛起》等影视作品中</p>
<h5 id="颗粒材质"><a href="#颗粒材质" class="headerlink" title="颗粒材质"></a>颗粒材质</h5><p>砂砾，谷物，粉末这些材质都属于颗粒材质，这些材质渲染的计算量非常大，但可以做一些简化，用百分比来表示单个渲染单元的组成成分，不过即使如此，颗粒材质至今仍然没有得到有效的优化</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E9%A2%97%E7%B2%92%E6%9D%90%E8%B4%A8.png" alt="颗粒材质"></p>
<h4 id="表面模型"><a href="#表面模型" class="headerlink" title="表面模型"></a>表面模型</h4><h5 id="半透明材质"><a href="#半透明材质" class="headerlink" title="半透明材质"></a>半透明材质</h5><p>玉石这类材质是半透明材质（Translucent）的典型代表，注意translucent和semitransparent的区别，这里说的半透明是光线在材质内发生散射，最后从另一个点出来，对应到物理，这种现象被称为次表面散射</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E6%AC%A1%E8%A1%A8%E9%9D%A2%E6%95%A3%E5%B0%84.png" alt="次表面散射"></p>
<p>现实中可能用到次表面散射的情景有如渲染人耳，牛奶等材质，可以看到，光线通过人耳后并未被完全阻挡，而是表现为红光</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/BSSRDF.png" alt="BSSRDF"></p>
<p>在图形学中，通常使用BSSRDF方程来描述次表面散射，它可以被认为是BSDF的拓展，BSDF计算贡献时只会计算当前着色点，而BSSRDF还需要考虑其他渲染单元射入的光线，因为这些光线在材质内发生散射后，同样有可能对当前着色点的能量造成影响</p>
<p>来看看BSSRDF的效果</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/BSSRDF%E6%95%88%E6%9E%9C1%EF%BC%881%EF%BC%89.png" alt="BSSRDF效果1（1）"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/BSSRDF%E6%95%88%E6%9E%9C1%EF%BC%882%EF%BC%89.png" alt="BSSRDF效果1（2）"></th>
</tr>
</thead>
<tbody><tr>
<td><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/BSSRDF%E6%95%88%E6%9E%9C2.png" alt="BSSRDF效果2"></td>
<td><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/BSSRDF%E6%95%88%E6%9E%9C3.png" alt="BSSRDF效果3"></td>
</tr>
</tbody></table>
<p>在应用时，我们也可以用Dipole方法做近似，即在表面上下各假设一个虚拟光源，来模拟次表面散射的光照效果</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Dipole%E8%BF%91%E4%BC%BC.png" alt="Dipole近似"></p>
<h5 id="布料模拟"><a href="#布料模拟" class="headerlink" title="布料模拟"></a>布料模拟</h5><p>我们先来看布料的微观组成：纤维 -&gt; 纱线 -&gt; 布料</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%B8%83%E6%96%99%E7%BB%84%E6%88%90.png" alt="布料组成"></p>
<p>其中编制方法还分woven和knitted两种，不再细说</p>
<p>下面来看布料模拟中常用的几种方法，最简单粗暴的，直接根据不同布料给出BRDF，但这种方法无法渲染天鹅绒等材质</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F2.png" alt="布料模拟2"></p>
<p>因为天鹅绒本身就不能归为表面模型，所以接下去我们直接把布料看做是空间中的微小体积的集合，当做散射介质就像渲染云雾那样去渲染布料，这个计算量是肉眼可见的大</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F3.png" alt="布料模拟3"></p>
<p>当这些体积被细分到纤维级别时，计算量是难以想象的，但效果也无限接近真实</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F4.png" alt="布料模拟4"></p>
<h5 id="细节模型"><a href="#细节模型" class="headerlink" title="细节模型"></a>细节模型</h5><p>至今为止讲的所有真实感渲染都忽略了一件事，那就是现实世界中的物体大多数都是不完美的，多多少少都会带点瑕疵，比如风雨灰尘在车漆上留下的细微划痕，或物件老化磨损，等等等等，现实世界的情况往往比理论更加复杂</p>
<p>想要在渲染时考虑这些微小的因素，我们在之前提到微表面模型的时候有强调过使用法线分布来描述微观表面的起伏，但那时候说的法线分布，大部分是正态分布之类的简单分布，这并不是我们真正想要的</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%BE%AE%E8%A1%A8%E9%9D%A2%E5%9B%9E%E9%A1%BE.png" alt="微表面回顾"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%BE%AE%E8%A1%A8%E9%9D%A2%E5%9B%9E%E9%A1%BE2.png" alt="微表面回顾2"></th>
</tr>
</thead>
</table>
<p>我们当然可以人为的往这些分布上加一些细节扰动，但想真正把它渲染出来是非常困难的</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E7%BB%86%E8%8A%82%E6%A8%A1%E5%9E%8B.png" alt="细节模型"></p>
<p>闫神：《关于自己的头像是自己渲染了一个月的研究结果这档事》</p>
<p>除此之外，细节模型还存在一个问题，就是在计算镜面反射时，如果法线分布比较复杂，就很难建立有效的，从光源到微表面再到摄像机的光线通路，为了解决这个问题，我们让每个像素打出路径时都对应一个范围，如图，把整块范围内的法线分布整合起来得到P-NDF，从而简化计算</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/P%20NDF1.png" alt="P NDF1"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/P%20NDF2.png" alt="P NDF2"></th>
</tr>
</thead>
</table>
<p>单独看这些P-NDF，单个像素覆盖的微表面范围大小不同，P-NDF所呈现出来的特点也各不相同</p>
<p>当范围选取的大，P-NDF会趋于符合一些统计学规律，而当范围选取的小，这些P-NDF则会展现出一些很奇妙的形态</p>
<p>并且，不同类型的法线分布也会得到不同的P-NDF图像，各向同性的P-NDF与各向异性材质完全不同</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/P%20NDF3.png" alt="P NDF3"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/P%20NDF4.png" alt="P NDF4"></th>
</tr>
</thead>
</table>
<p>再深入，就要考虑到微表面上光的波粒二象性了，比如干涉衍射，这些太复杂，并且只有在很小的尺度下，波动性才会起作用，在这里就不细说了，但可以看看考虑了波动光学的BRDF和几何光学BRDF的区别：</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%BE%AE%E8%A1%A8%E9%9D%A2%E7%9A%84%E6%B3%A2%E5%8A%A8%E6%80%A7.png" alt="微表面的波动性"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E8%80%83%E8%99%91%E5%BE%AE%E8%A1%A8%E9%9D%A2%E7%9A%84%E6%B3%A2%E5%8A%A8%E6%80%A7%E7%9A%84BRDF.png" alt="考虑微表面的波动性的BRDF"></th>
</tr>
</thead>
</table>
<p>结果和几何光学极为相近，但它的图像是不连续的</p>
<h4 id="程序化生成材质"><a href="#程序化生成材质" class="headerlink" title="程序化生成材质"></a>程序化生成材质</h4><p>之前再说纹理的时候就有简单提到过程序纹理，对应到材质这块，这个过程就是通过程序来指导材质的生成</p>
<p>这里的程序化生成并没有真正的生成材质，而是将这个材质信息定义为空间中的一些噪声函数，在后续生成时动态的查询它</p>
<p>（存储三维的纹理会耗费很多内存）</p>
<p>噪声函数的应用非常广泛，比如可以二值化定义车锈</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%94%9F%E6%88%90%E8%BD%A6%E9%94%88.png" alt="程序化生成车锈"></p>
<p>现在应用最广泛的噪声函数是柏林噪声（Perlin Noise），有了这些噪声函数，我们不仅可以程序化生成材质，还可以程序化生成地形，程序化生成水面等，另外，由于这个噪声函数是定义在空间中的，所以如果我们在空间里切割一块木头（或其他材质），是能看到里面的纹理的，这是二维材质做不到的</p>
<p>Houdini是目前工业上用来程序化生成材质的工具，它并非如上所述定义了函数供后续查询，而是直接生成了材质拿去用…</p>
<p>这个工具也渐渐的成为了目前游戏TA必备的工具技能之一</p>
<h2 id="九、相机，透镜，光场"><a href="#九、相机，透镜，光场" class="headerlink" title="九、相机，透镜，光场"></a>九、相机，透镜，光场</h2><p>这一章内容比较独立，相较之前是一个全新的话题（个人认为老师这块讲的有点乱，所以对顺序做了一定调整）</p>
<h3 id="成像"><a href="#成像" class="headerlink" title="成像"></a>成像</h3><p>成像方法大体上可以分为合成成像（Synthesis）和捕捉成像（Capture）两种，我们之前讲的光栅化成像和光线追踪就都属于合成方法成像，而另一类捕捉成像，则是直接捕捉现实图片，相机成像就是一个典型的例子</p>
<p>关于其他的一些成像方法，如研究光在极短时间内如何传播（Transient Imaging）等，目前也正在研究之中…</p>
<p>整个成像的范畴更多是在计算摄影学（Computational Photography）中研究，算是计算机图形学的一个交叉学科</p>
<h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><h4 id="小孔成像与针孔相机"><a href="#小孔成像与针孔相机" class="headerlink" title="小孔成像与针孔相机"></a>小孔成像与针孔相机</h4><p>最早人们从小孔成像开始研究相机，以小孔成像为原理的相机叫做针孔相机</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%B0%8F%E5%AD%94%E6%88%90%E5%83%8F.png" alt="小孔成像"></p>
<p>针孔相机拍出的东西是没有深度可言的，像的所有地方都是锐利的，而透镜成像则会产生虚化，这在之后会进一步展开讨论</p>
<p>之前光线追踪所用的相机就可以看做是一个针孔相机模型，所以我们的渲染结果得不到景深的模糊效果</p>
<p>如果想要得到带有景深的渲染效果，则必须考虑如何在计算机中模拟光线和透镜的作用</p>
<p>注意，成像过程中，透镜或小孔是不可或缺的，因为我们如果要使我们成的像清晰，必须清楚的区分来自各个不同方向的光，如果直接把感光元件放在捕捉对象面前，感光元件上任何一个点都会收集到来自不同方向的光照信息，叠加计算记录的就是Irradiance，而Irradiance是没有方向的概念的，成像自然会糊。换句话说，传感器没法直接记录Radiance，所以只能依靠透镜或小孔来辅助</p>
<p>（现实中是存在直接记录Radiance的相机的（光场相机），这在后面会提到）</p>
<h4 id="传感器与视场"><a href="#传感器与视场" class="headerlink" title="传感器与视场"></a>传感器与视场</h4><p>传感器（sensor）（or感光元件）是用来捕捉记录光线信息的部件，它与胶片（film）在渲染中并不完全等价，在渲染器中，sensor收集信息，film决定储存格式，但大多数时候我们认为他们是一种东西</p>
<p>视场（field of view，FoV）指的是相机的拍摄范围，其大小与传感器大小以及焦距有关</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%A7%86%E5%9C%BA1.png" alt="视场1"></p>
<p>两个参数共同作用下视场大小是很难被衡量的，所以我们通常固定传感器的大小，通过变换焦距来控制其大小（现实中一般相机通常为35mm），这也是市面上买单反镜头有焦距的区别而没有传感器大小区别的原因</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%A7%86%E5%9C%BA2.png" alt="视场2"></p>
<p>总结来说，传感器大小相同，焦距越大，视场越窄；焦距相同，传感器越大，视场越宽；视大小相同场，焦距和传感器成比例</p>
<p>下面一系列参数得到的视场大小是相同的，不同传感器对应了不同的设备</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%A7%86%E5%9C%BA4.png" alt="视场4"></p>
<h4 id="曝光"><a href="#曝光" class="headerlink" title="曝光"></a>曝光</h4><p>理论定义：曝光值$H&#x3D;T\times E$</p>
<p>T表示曝光时间，主要由快门控制</p>
<p>E表示Irradiance，由光圈和焦距共同决定</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E6%9B%9D%E5%85%89%E5%80%BC%E5%AE%9A%E4%B9%89.png" alt="曝光值定义"></p>
<p>摄影中控制曝光值主要有三大要素：快门、光圈、感光度</p>
<h5 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h5><p>快门是用来控制光线照射感光元件的时间的部件</p>
<p>工作动画：</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%BF%AB%E9%97%A8%E5%8A%A8%E7%94%BB.gif" alt="快门动画"></p>
<p>快门主要有两个作用：①影响曝光；②影响被摄影物体的形态</p>
<p><u>影响曝光：</u></p>
<p>快门打开时间越长（更长的曝光时间），相机记录的光线就越多，照片越亮，反之则光线少，照片较暗</p>
<p>另外，更长的曝光时间也越容易得到运动模糊的效果，就类似光栅化中的反走样，只不过它是对于时间采样的反走样</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E6%9B%9D%E5%85%89%E6%97%B6%E9%97%B4.png" alt="曝光时间"></p>
<p>运动模糊并不总是有害的，有时候我们为了表达被拍摄物体的速度感，会刻意的希望加上一些运动模糊</p>
<p><u>影响被摄影物体的形态：</u></p>
<p>快门关闭和打开的过程也是需要时间的，我们定义<strong>快门速度（shutter speed）</strong>这一参数来衡量它</p>
<p>快门速度越快，被拍摄的高速物体越清晰，反之则会有一定形变</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%BF%AB%E9%97%A8%E9%80%9F%E5%BA%A6.jpg" alt="快门速度"></p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%BF%AB%E9%97%A8%E9%80%9F%E5%BA%A6.png" alt="快门速度"></p>
<h5 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h5><p>光圈是一种仿照人类瞳孔的仿生学的设计，由多个小叶片相互重叠而成的光孔，调节其开闭可以控制感光元件的受光量</p>
<p>光圈越大，进光量越多，照片越亮，反之越暗</p>
<p>一般通过F数来表示其大小，F数的明确定义在后面会提及，这里可以先暂时理解为光圈直径的倒数</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%85%89%E5%9C%881.jpg" alt="光圈1"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%85%89%E5%9C%883.jpg" alt="光圈3"></th>
</tr>
</thead>
</table>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%85%89%E5%9C%882.jpg" alt="光圈2"></p>
<p>除此之外，光圈还会影响画面景深，相关内容在之后薄透镜近似中也会详细说明</p>
<h5 id="感光度（ISO）"><a href="#感光度（ISO）" class="headerlink" title="感光度（ISO）"></a>感光度（ISO）</h5><p>感光度表示的是相机感光元件对光线的敏感程度</p>
<p>感光度越高，相机感光元件对光线敏感程度越强，照片越亮；感光度越低，相机感光元件对光线敏感程度越弱，照片越暗</p>
<p>但是，随着感光度的增加，感光元件对一些噪声的敏感程度也随之增加，画面就会逐渐出现一些噪点</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E6%84%9F%E5%85%89%E5%BA%A6.png" alt="感光度"></p>
<p>总结来说，快门、光圈、感光度对曝光的影响总结如下</p>
<table>
<thead>
<tr>
<th align="center">快门</th>
<th align="center">影响曝光和被摄物体形态</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>光圈</strong></td>
<td align="center"><strong>影响进光量和画面景深</strong></td>
</tr>
<tr>
<td align="center"><strong>感光度</strong></td>
<td align="center"><strong>影响曝光和画质</strong></td>
</tr>
</tbody></table>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%BD%B1%E5%93%8D%E6%9B%9D%E5%85%89%E4%B8%89%E8%A6%81%E7%B4%A0.png" alt="影响曝光三要素"></p>
<p>相关概念详细可参考：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/134166476">https://zhuanlan.zhihu.com/p/134166476</a></p>
<p>光圈和快门共同控制<strong>进光量</strong>：</p>
<p>以下光圈大小和快门速度参数所控制的进光量相同，可以看到光圈F数的平方与快门速度成正比，因为对于进光量，应该算的是光圈大小，也就是面积，而不是直径<br>$$<br>F^2\propto Shutter\ Speed<br>$$<br><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%BF%9B%E5%85%89%E9%87%8F.png" alt="进光量"></p>
<p>实际应用方面，在拍摄流光轨迹、延时摄影等慢门题材时，宜用慢速快门和小光圈，而在拍摄高速题材时，宜用高速快门和大光圈，具体可以参照链接最后的部分</p>
<h3 id="薄透镜近似"><a href="#薄透镜近似" class="headerlink" title="薄透镜近似"></a>薄透镜近似</h3><p>真实的透镜并不会如我们想的那么理想，比如下图中的透镜，它无法正确的将光线聚焦为一点，从而出现像差（Aberrations）</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%83%8F%E5%B7%AE.png" alt="像差"></p>
<p>并且，现实中我们用的相机一般用的都不是单个透镜，而是一个透镜组，这比理想情况复杂的多，在此不做过多讨论</p>
<p>这里我们只考虑理想化的透镜：</p>
<ul>
<li>所有进入透镜的平行光线都通过透镜的焦点</li>
<li>穿过焦点的所有光线在通过透镜后将是平行的</li>
<li>焦距可以任意改变（实际上用透镜组改变焦距)</li>
</ul>
<h4 id="薄透镜方程"><a href="#薄透镜方程" class="headerlink" title="薄透镜方程"></a>薄透镜方程</h4><p>这个方程属于初中内容，简单推导如下：</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%96%84%E9%80%8F%E9%95%9C%E6%96%B9%E7%A8%8B1.png" alt="薄透镜方程1"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%96%84%E9%80%8F%E9%95%9C%E6%96%B9%E7%A8%8B2.png" alt="薄透镜方程2"></th>
</tr>
</thead>
</table>
<p>$$<br>\frac{h_o}{z_o-f}&#x3D;\frac{h_i}{f}\Rightarrow \frac{h_o}{h_i}&#x3D;\frac{z_o-f}{f}\ \ ①\<br>\frac{h_o}{f}&#x3D;\frac{h_i}{z_i-f}\Rightarrow \frac{h_o}{h_i}&#x3D;\frac{f}{z_i-f}\ \ ②\<br>联立①，②:\ \ \frac{z_o-f}{f}&#x3D;\frac{f}{z_i-f}\<br>f^2&#x3D;(z_o-f)(z_i-f)\<br>z_oz_i-(z_o+z_i)f+f^2&#x3D;f^2\<br>\frac{1}{f}&#x3D;\frac{1}{z_o}+\frac{1}{z_i}<br>$$<br>动态演示链接：</p>
<p><a target="_blank" rel="noopener" href="http://graphics.stanford.edu/courses/cs178-10/applets/gaussian.html">http://graphics.stanford.edu/courses/cs178-10/applets/gaussian.html</a></p>
<h4 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h4><h5 id="CoC"><a href="#CoC" class="headerlink" title="CoC"></a>CoC</h5><p>当传感器不在物体真正的成像平面上时，光线会继续沿直线传播，在感光元件上形成一个弥散圈，这个圈就叫CoC（Circle of Confusion）</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/CoC.png" alt="CoC"></p>
<p>上图的关系式告诉我们，光圈越大，越容易出现模糊</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/CoC2.png" alt="CoC2"></p>
<h5 id="F数"><a href="#F数" class="headerlink" title="F数"></a>F数</h5><p>之前我们简单理解F数为光圈直径的倒数，实际上，其确切的定义是焦距除以光圈直径</p>
<p>F数为n的光圈一般记作f&#x2F;n，如下图中F数为2，则记作f&#x2F;2</p>
<p>常用的F数还有f&#x2F;1.4，f&#x2F;2.8，f&#x2F;4.6，f&#x2F;5.0，f&#x2F;8，f&#x2F;11，f&#x2F;16，f&#x2F;22，f&#x2F;32等</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/F%E6%95%B01.png" alt="F数1"></p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/F%E6%95%B02.png" alt="F数2"></p>
<p>上图公式进一步说明，拍摄带有虚化的照片要用大光圈，而拍摄清晰照片要用小光圈</p>
<h5 id="景深定义"><a href="#景深定义" class="headerlink" title="景深定义"></a>景深定义</h5><p>在实际拍摄过程中，如果要得到足够清晰的像，其实并不需要将物体完美对焦在焦点平面上，只要CoC大致小于胶片传感器上像素的大小，就可以被认为是成功对焦了，如此一来，一个物体可以成功对焦就有了一个距离范围，这个范围就是景深（DoF，depth of field）</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E6%99%AF%E6%B7%B11.png" alt="景深1"></p>
<p>景深公式推导如下：</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E6%99%AF%E6%B7%B12.png" alt="景深2"></p>
<p>动态演示链接：</p>
<p><a target="_blank" rel="noopener" href="http://graphics.stanford.edu/courses/cs178/applets/dof.html">http://graphics.stanford.edu/courses/cs178/applets/dof.html</a></p>
<h4 id="光线追踪中的薄透镜近似"><a href="#光线追踪中的薄透镜近似" class="headerlink" title="光线追踪中的薄透镜近似"></a>光线追踪中的薄透镜近似</h4><p>之前在做光线追踪的时候我们的相机都是假设为一个小点，即默认小孔成像，如此成像得到的结果是完全清晰、没有景深的</p>
<p>但现在我们就可以通过模拟薄透镜来近似做出景深的效果，如图</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%85%89%E8%BF%BD%E8%96%84%E9%80%8F%E9%95%9C%E8%BF%91%E4%BC%BC.png" alt="光追薄透镜近似"></p>
<p>首先我们要确定薄透镜的大小和位置，由此确定光圈和焦距，然后在透镜和传感器（像素屏幕）上分别采样，并连接成一条线</p>
<p>这条光线经过折射后偏转，打到物体的x’’’处，计算x‘’‘到x’’的radiance并记录在x’处，这就是一条光追路径的薄透镜近似流程</p>
<h3 id="光场"><a href="#光场" class="headerlink" title="光场"></a>光场</h3><p>关于光场的英文名称，Light Field &#x2F; Lumigraph 两个词其实是指的同一个东西，在这里我们用Light Field</p>
<p>首先来看我们是怎么看这个世界的</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9E%E5%8E%9F%E7%90%861.png" alt="虚拟现实原理1"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9E%E5%8E%9F%E7%90%862.png" alt="虚拟现实原理2"></th>
</tr>
</thead>
</table>
<p>我们眼中的三维世界其实可以类比为一张图片，现实中如果我们在一张图片或者一块幕布上直接记录我们这一刻所看到的所有信息，并把它放在我们的眼前，我们感受到的结果是完全一样的，这也就是虚拟现实的实现原理</p>
<h4 id="全光函数"><a href="#全光函数" class="headerlink" title="全光函数"></a>全光函数</h4><p>全光函数是记录光线特征信息的函数，一般来说这些特征可以被分为四类：位置，角度，波长，时间</p>
<table>
<thead>
<tr>
<th align="center">$P(\theta,\phi)$</th>
<th align="center">最简单的全光函数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$P(\theta,\phi,\lambda)$</td>
<td align="center"><strong>引入颜色</strong></td>
</tr>
<tr>
<td align="center">$P(\theta,\phi,\lambda,t)$</td>
<td align="center"><strong>引入时间，可以类比看电影</strong></td>
</tr>
<tr>
<td align="center">$P(\theta,\phi,\lambda,t,V_X,V_Y,V_Z)$</td>
<td align="center"><strong>引入观测位置坐标，相当于全息电影</strong></td>
</tr>
</tbody></table>
<h4 id="采样全光函数"><a href="#采样全光函数" class="headerlink" title="采样全光函数"></a>采样全光函数</h4><p>所谓光场，就是对全光函数的采样，可以理解为全光函数的一个子集，因为现实中光线的颜色特征通常由RGB通道记录，而时间信息通常由动画帧来记录，所以对于光场来说只需要关注方向和位置即可，这样一来，原本七维的信息就被降至为了五维<br>$$<br>P(\theta,\phi,V_X,V_Y,V_Z)<br>$$<br>后来，人们发现只需要四维的信息（二维位置信息uv + 二维方向信息θφ）就可以定义光线的方向和位置；再后来，索性方向信息也不要了，直接定义两个平面，两平面上任意两点连线就可以表示空间中任意一条光线</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/uvst1.png" alt="uvst1"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/uvst2.png" alt="uvst2"></th>
</tr>
</thead>
</table>
<p>光场降维过程的通俗解释：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/393235387/answer/1215239335">https://www.zhihu.com/question/393235387/answer/1215239335</a></p>
<p>对相机来说，uv可以理解为传感器 &#x2F; 成像平面，st可以理解为镜头 &#x2F; 光圈平面</p>
<p>进一步用采样来理解这个过程，如图</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/uvst3.png" alt="uvst3"></p>
<p>1° 固定(u,v)，对st平面采样，此时的采样结果可以理解为从uv上某点沿各个方向观察世界的结果</p>
<p>2° 固定(s,t)，对uv平面采样，此时的采样结果可以理解为从uv上各个不同的点以不同角度观察世界中某一点的结果</p>
<p>更多关于这方面的理解可以参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24982662">https://zhuanlan.zhihu.com/p/24982662</a></p>
<p>现实中模拟这种方式记录光场，有斯坦福的相机阵列（Stanford Multi-Camera Array），另外，自然界中苍蝇的复眼也是用类似的方式来感知外界信息的，也就是说苍蝇所接受到的信息不是Irradiance，而是经过复眼分光的Radiance信息</p>
<h4 id="光场相机"><a href="#光场相机" class="headerlink" title="光场相机"></a>光场相机</h4><p>光场相机顾名思义就是能记录光场的相机，它最重要的功能在于它支持先拍照，然后在后期重新对焦</p>
<p>原理：将原本的成像面的每个像素都换成微透镜（相当于st），再在成像面后面真正的去使用传感器记录信息（相当于uv）</p>
<p>其实记录之前还有一个校正的过程，在这里不做细说</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%85%89%E5%9C%BA%E7%9B%B8%E6%9C%BA%E5%8E%9F%E7%90%86.png" alt="光场相机原理"></p>
<p>普通相机的传感器像素记录的是irradiance，但是对于光场相机来说，它们记录的分光之后的分量，也就是记录的是Radiance（感觉光场相机就是由昆虫复眼产生的灵感造出来的）</p>
<p>那么，我们又要怎么通过光场相机记录的光场信息得到最后的相片呢？</p>
<p>很简单，对于每个微透镜，在经过它的光线中只选择一条，这样每个微透镜就都对应了一个值，然后把这个值作为当前传感器像素的值</p>
<p>如图所示，可以统一选择最下面的光线，也可以选择中间那根，这样就可以实现虚拟的移动相机的位置，并且这种方式得到的光照信息也是正确的（并不是简简单单的平移图像）</p>
<p>选光线的步骤称为重新聚焦，可以参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24983091">https://zhuanlan.zhihu.com/p/24983091</a></p>
<p>目前的光场相机也有它的局限：</p>
<ul>
<li><p>分辨率不足，光场相机的每个像素都相当于要记录一个像素组，在同样的胶片尺寸下，光场相机的分辨率往往会很低</p>
</li>
<li><p>成本高、难设计，对仪器的精密程度大大提高，就比如微透镜组</p>
</li>
</ul>
<h2 id="十、颜色与感知"><a href="#十、颜色与感知" class="headerlink" title="十、颜色与感知"></a>十、颜色与感知</h2><h3 id="颜色的物理学基础"><a href="#颜色的物理学基础" class="headerlink" title="颜色的物理学基础"></a>颜色的物理学基础</h3><p>人们对颜色的研究是从牛顿三棱镜色散实验开始的，自此之后人们就意识到有色光是不同波长的光混合起来的结果这一事实</p>
<p>光之所以会发生色散是因为不同波长的光具有不同的折射率，所有经过色散得到的单色光按波长大小依次排列频谱称为光谱，而图形学仅关心光谱中的可见光（波长范围400~700nm）</p>
<p>在光谱的基础上，我们再提出一个更准确的概念，用<strong>谱功率密度</strong>来描述光线在不同波长的强度分布，如图</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/SPD1.png" alt="SPD1"></p>
<p>SPD具有&#x3D;&#x3D;线性的性质&#x3D;&#x3D;，如果两个不同光线叠加，那么他们的谱功率密度分布就是他们各自的SPD相加的结果</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/SPD2.png" alt="SPD2"></p>
<h3 id="颜色的生物学基础"><a href="#颜色的生物学基础" class="headerlink" title="颜色的生物学基础"></a>颜色的生物学基础</h3><p>从生物学角度看色彩，我们发现颜色是人类的感知，而并不是光线本身的属性，同样的光线在其他动物眼里呈现的色彩是不一样的，正是因为人类具有丰富的视觉细胞，才能感受到不同波长的光所组成的多彩的世界</p>
<p>来看看生物学上关于人类的视觉器官的结构：</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E7%9C%BC%E7%90%83%E7%BB%93%E6%9E%84.png" alt="眼球结构"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E8%A7%86%E8%A7%89%E7%BB%86%E8%83%9E.png" alt="视觉细胞"></th>
</tr>
</thead>
</table>
<p>人类眼球可以类比为一个摄像机，晶状体就相当于透镜，视网膜相当于传感器，而调整焦距的过程是由肌肉拉扯晶状体来完成的</p>
<p>在视网膜上有各种感光细胞，总体上分为视锥细胞和视杆细胞两类，视杆细胞用来感知光强，视锥细胞感知颜色</p>
<p>视锥细胞还可以进一步分为S，M，L三类，不同的视锥细胞对不同波长的光的敏感度不同，而不同人的这三种视锥细胞的分布也不同，这也说明了在不同人眼里看到的世界是截然不同的</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/SML1.png" alt="SML1"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/SML2.png" alt="SML2"></th>
</tr>
</thead>
</table>
<p>对于一条光线，人眼这三种视锥细胞感知到的结果，分别都是&#x3D;&#x3D;细胞对波长的响应程度&#x3D;&#x3D;和&#x3D;&#x3D;谱功率密度&#x3D;&#x3D;乘积的积分</p>
<p>如此得到对应的SML值后，将其相加混合（格拉斯曼定律），就得到了最后我们感觉到的颜色</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E4%B8%89%E8%89%B2%E6%BF%80%E5%8A%B11.png" alt="三色激励1"></p>
<p>人眼处理外界颜色信息的过程：</p>
<p>光线（带有spd信息）	→	视锥细胞将spd转化成sml	→	大脑将接受到的sml与感觉到的颜色一一对应</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E4%B8%89%E8%89%B2%E6%BF%80%E5%8A%B12.png" alt="三色激励2"></p>
<p>也就是说，人所感知到的颜色信息并不是光线本身的spd属性，而是视锥细胞sml所接受到的信息</p>
<h3 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a>色彩空间</h3><h4 id="同色异谱"><a href="#同色异谱" class="headerlink" title="同色异谱"></a>同色异谱</h4><p>既然我们感受到的不是spd，那理论上不同spd的光也有可能被人眼处理为相同的颜色，这种现象是实际存在的，即我们所说的“同色异谱”</p>
<p>正是因为有这个现象，我们才能通过计算机进行颜色匹配，从而调和不同光谱来模拟我们想要得到的颜色</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E5%90%8C%E8%89%B2%E5%BC%82%E8%B0%B1.png" alt="同色异谱"></p>
<h4 id="色匹配函数"><a href="#色匹配函数" class="headerlink" title="色匹配函数"></a>色匹配函数</h4><p>色匹配函数其实是建立在实验基础上的</p>
<p>实验过程大致是，用一块不透明挡板将一个屏幕分割为两个区域，左边照射要被匹配的颜色的光线，右边同时用rgb三种颜色的光同时照射，然后调节右边三种颜色光源的强度，直到左右两边的颜色看上去一样为止，随后记录对应需要的rgb强度，如此反复，将光谱上所有颜色依次匹配，最后得到曲线就是色匹配函数——&#x3D;&#x3D;CIE-RGB&#x3D;&#x3D;</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/CIERGB.png" alt="CIERGB"></p>
<p>这时候我们发现，红色曲线部分地方出现的负值，这是因为在一些情况下，无论怎么调节右侧的光源强度，都无法得到期望的颜色，只能通过在左边的颜色上加上三色光的一种或几种来完成匹配，在左边加，就等价于在右边减，所以出现负值是在情理之中的</p>
<h4 id="CIE-XYZ空间"><a href="#CIE-XYZ空间" class="headerlink" title="CIE-XYZ空间"></a>CIE-XYZ空间</h4><p>虽然色匹配函数允许出现负值，但负数的出现多少对计算会造成一些影响，为了消除这种影响，国际照明委员会（CIE）就对原来的色匹配函数做了一次线性变换，提出了一种所有分量都为正值的颜色空间，就是我们所谓的CIE-XYZ空间</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/CIEXYZ.png" alt="CIEXYZ"></p>
<p>因为只是在原来基础上做了一次线性空间的变换，所以既然CIE-RGB可以表示所有颜色，CIE-XYZ也可以，二者之间是完全等价的</p>
<h4 id="色域-屏幕色彩空间"><a href="#色域-屏幕色彩空间" class="headerlink" title="色域&amp;屏幕色彩空间"></a>色域&amp;屏幕色彩空间</h4><p>由上我们知道，任何一个颜色都能被三个参数的线性组合表示出来，也就是说颜色本身属于一种三维的信息</p>
<p>为了更方便表示，我们通常会将其降至二维，通过归一化使三个参数的和为1，这时候就只需要两个参数就能表示颜色空间中任意一个颜色了，而这种表示方式所得到的颜色集合，我们就称之为色域</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E8%89%B2%E5%9F%9F.png" alt="色域"></p>
<p>但是到这里为止，我们还是无法将颜色显示在计算机的屏幕上，因为计算机屏幕并不是人眼，他所支持的色域通常会比可见光色域小得多，那这时候我们就必须把计算得到的 XYZ 转换到屏幕空间中（空间变换和gamma校正），而因为不同设备的转码方式不同，就形成了不同设备各自的色彩空间</p>
<p>由上图我们可以直观的看到不同色彩空间所能表示的色域范围</p>
<p>常见的色彩空间有sRGB，Adobe RGB等，还有一些其他的RGB空间，比如用色调、饱和度、亮度表示的色彩空间HSV，和CIE用互补色表示的色彩空间等，就不再一一列举了</p>
<table>
<thead>
<tr>
<th align="center">HSV</th>
<th align="center">CIE-LAB</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/HSV.png" alt="HSV"></td>
<td align="center"><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/CIELAB.png" alt="CIELAB"></td>
</tr>
</tbody></table>
<p>关于CIE-LAB的互补色，还可以多提几句，美术中的互补色通常指红黄蓝（RYB）色相环中成180°角的两种颜色，这两种颜色放在一起会给人一种强烈对比的色觉，并有时会产生主观上的感知错觉（详例见ppt），这进一步证明色彩是人的感知，而不是光本身的属性</p>
<p>关于这方面知识更为系统的解释：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24214731">https://zhuanlan.zhihu.com/p/24214731</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24281841">https://zhuanlan.zhihu.com/p/24281841</a></p>
<p>gamma校正：</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/gamma%20(1).jpg" alt="gamma (1)"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/gamma%20(3).jpg" alt="gamma (3)"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/gamma%20(2).jpg" alt="gamma (2)"></th>
</tr>
</thead>
</table>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36581276">https://zhuanlan.zhihu.com/p/36581276</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/candycat1992/article/details/46228771/">https://blog.csdn.net/candycat1992/article/details/46228771/</a></p>
<p>关于三原色：</p>
<p>光学三原色和绘画三原色是不一样的，光学三原色是红绿蓝rgb，美术三原色是品红，黄和靛青</p>
<p>光学三原色是加色模型，美术三原色是减色模型</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E4%B8%89%E5%8E%9F%E8%89%B21.png" alt="三原色1"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E4%B8%89%E5%8E%9F%E8%89%B22.png" alt="三原色2"></th>
</tr>
</thead>
</table>
<p>右图为UE中材质结点关于加色模型和减色模型的一个直观展示</p>
<h2 id="十一、动画与仿真"><a href="#十一、动画与仿真" class="headerlink" title="十一、动画与仿真"></a>十一、动画与仿真</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><h4 id="动画历史"><a href="#动画历史" class="headerlink" title="动画历史"></a>动画历史</h4><p>动画在最开始是作为一种沟通交流而存在的工具，它所传递的信息更富于美学意义</p>
<p>在图形学中，动画可以被认为是对3d建模和几何在时间上的拓展（升维）</p>
<h5 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h5><table>
<thead>
<tr>
<th align="center">3200BC-远古时期</th>
<th align="center">人类壁画——Shahr-e Sukhteh, 伊朗</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1931</td>
<td align="center">Phenakistoscope圆盘，通过转动圆盘来做动画</td>
</tr>
<tr>
<td align="center">1878</td>
<td align="center">第一部电影——Sallie Gardner</td>
</tr>
<tr>
<td align="center">1937</td>
<td align="center">第一部剧场版手绘电影——白雪公主与七个小矮人</td>
</tr>
<tr>
<td align="center">1963</td>
<td align="center">第一个计算机生成的动画</td>
</tr>
<tr>
<td align="center">1972</td>
<td align="center">早期计算机动画，人脸动画</td>
</tr>
<tr>
<td align="center">1993</td>
<td align="center">侏罗纪公园</td>
</tr>
<tr>
<td align="center">1995</td>
<td align="center">第一部完全计算机生成的动画电影——玩具总动员</td>
</tr>
<tr>
<td align="center">2009</td>
<td align="center">天降美食</td>
</tr>
<tr>
<td align="center">2019</td>
<td align="center">冰雪奇缘2</td>
</tr>
</tbody></table>
<h4 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h4><p>最早期的动画制作一般由画师画出关键的画面，再由其助手补全关键帧之间的过渡</p>
<p>所以关键帧动画的主要问题在于使用怎样的插值方法得到更为平滑的过渡</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB1.png" alt="关键帧动画1"></p>
<p>通常来说线性插值是无法满足平滑过渡的需求的，所以一般会用贝塞尔，b样条之类的几何插值技术</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB2.png" alt="关键帧动画2"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB3.png" alt="关键帧动画3"></th>
</tr>
</thead>
</table>
<h4 id="物理模拟"><a href="#物理模拟" class="headerlink" title="物理模拟"></a>物理模拟</h4><p>物理模拟一般指 通过建立物理模型来还原诸如流体，布料等基于真实情况的动画</p>
<h5 id="质点弹簧系统"><a href="#质点弹簧系统" class="headerlink" title="质点弹簧系统"></a>质点弹簧系统</h5><p>质点弹簧系统是一系列相互连接的质点和弹簧，最简单的一种是理想弹簧，如图</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E7%90%86%E6%83%B3%E5%BC%B9%E7%B0%A7.png" alt="理想弹簧"></p>
<p>理想弹簧没有初始长度，且满足牛顿第三定律，用胡克定律求解作用力的大小</p>
<p>在理想弹簧的基础上引入原长，就变成了非零长弹簧</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E9%9D%9E%E9%9B%B6%E9%95%BF%E5%BC%B9%E7%B0%A7.png" alt="非零长弹簧"></p>
<p>其中，$\frac{b-a}{|b-a|}$为归一化的力的方向，由于不考虑能量损失，非零长弹簧会始终保持运动的状态</p>
<p>如果简单引入摩擦力，则所有运动最后都会停止，如图</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E7%AE%80%E5%8D%95%E5%BC%95%E5%85%A5%E6%91%A9%E6%93%A6%E5%8A%9B.png" alt="简单引入摩擦力"></p>
<p>$-k_d$表示劲度系数，$\dot{b}$表示速度（x上加一点是导数的牛顿标记法）</p>
<p>这个模型的主要问题是无法考虑弹簧内部的相互作用力的影响，依然不接近真实情况</p>
<p>所以我们再引入一个内部的阻尼力</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E5%BC%95%E5%85%A5%E5%86%85%E9%83%A8%E4%BD%9C%E7%94%A8%E5%8A%9B.png" alt="引入内部作用力"></p>
<p>红框内表示b与a的相对速度在二者连线方向上的投影，是一个标量，再乘以b到a的归一化方向以及劲度系数，就得到的b上的总阻力</p>
<p>考虑完两个质点的相互作用，再来考虑弹簧系统，如何用这样一个系统来模拟纸或布料这种具有抗切变性质的材质</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E4%B8%89%E6%AD%A5%E4%BC%98%E5%8C%96%20(1).png" alt="三步优化 (1)"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E4%B8%89%E6%AD%A5%E4%BC%98%E5%8C%96%20(2).png" alt="三步优化 (2)"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E4%B8%89%E6%AD%A5%E4%BC%98%E5%8C%96%20(3).png" alt="三步优化 (3)"></th>
</tr>
</thead>
</table>
<p>抗切变：对于平面内的力，普通质点弹簧系统一拉就会变形，而抗切变材质不会；对于非平面力，质点弹簧系统可以做到完美对折，而抗切变材质不会</p>
<p>为了模拟这种情况，对原本的质点弹簧系统添加两步约束，如上图所示，一个是对角线的强约束，一个是跨顶点的弱约束</p>
<p>这样一来基本就可以得到物理正确的布料模拟了，但有时依旧不够精确</p>
<p>在渲染前沿话题中我们提到，布料的组成远比一个质点弹簧系统复杂（纤维，股，线），如果需要更为精确的模拟，首先在模型上的精度就得上去，其次还要得考虑质点间力的传导（有限元法，FEM），这样的模拟比较难做，在此略过</p>
<h5 id="粒子系统"><a href="#粒子系统" class="headerlink" title="粒子系统"></a>粒子系统</h5><p>粒子系统被广泛应用于图形与游戏行业，系统中每一个粒子的行为都会被一组人为设置的力所定义</p>
<p>一般来说，粒子生成的步骤如下：</p>
<p>生成粒子 -&gt; 计算每个粒子的力 -&gt; 更新每个粒子的位置和速度 -&gt; 将死亡的粒子移除 -&gt; 渲染到屏幕</p>
<p>粒子之间常见的作用力举例：重力，电磁力，摩擦力，空气阻力，粘滞力，碰撞等</p>
<p>粒子的模拟不仅限于计算机图形，现实中的大自然如鸟群行为，细胞结构都可以通过粒子模拟</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E9%B8%9F%E7%BE%A4%E8%A1%8C%E4%B8%BA.png" alt="鸟群行为"></p>
<h4 id="运动学"><a href="#运动学" class="headerlink" title="运动学"></a>运动学</h4><p>运动学大致分为正向运动学和逆向运动学</p>
<p>正向运动学是通过定义一些可活动关节（如铰链），通过计算来控制末端的点的运动</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E6%AD%A3%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A61.png" alt="正向运动学1"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E6%AD%A3%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A62.png" alt="正向运动学2"></th>
</tr>
</thead>
</table>
<p>虽然计算简单，但过程太过理性，艺术家习惯直接控制末端的点，而不是控制关节来间接运动</p>
<p>这种直接控制末端点的运动的方法，称为逆向运动学</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E9%80%86%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A61.png" alt="逆向运动学1"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E9%80%86%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A62.png" alt="逆向运动学2"></th>
</tr>
</thead>
</table>
<p>逆向运动学虽然直观形象，但它有一个很大的问题就是多解问题，要优化解的选择则涉及到深度学习（随机化算法、梯度下降等方法）</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/434238743">https://zhuanlan.zhihu.com/p/434238743</a></p>
<h4 id="角色绑定"><a href="#角色绑定" class="headerlink" title="角色绑定"></a>角色绑定</h4><p>角色绑定（Rigging）是指动画制作中涉及的骨骼创建、约束、蒙皮等操作，可以形象理解为提线木偶，是对逆运动学的一种应用</p>
<p>角色不同，每个角色的绑骨也都会不同，并且这一流程对后续动画制作会有直接影响，即角色的动作与动作之间原本需要对三维模型进行插值，现在只需要对骨骼插值即可</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E9%AA%A8%E9%AA%BC%E7%BB%91%E5%AE%9A.png" alt="骨骼绑定"></p>
<p>作为一个绑定师，需要同时具备艺术和技术才能</p>
<h4 id="动作捕捉"><a href="#动作捕捉" class="headerlink" title="动作捕捉"></a>动作捕捉</h4><p>既然可以通过绑骨来人为规定角色动作，那么这些信息同样也可以被捕捉记录下来，捕捉真实的控制点来生成动画</p>
<p>这种技术就是动捕技术</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E5%8A%A8%E4%BD%9C%E6%8D%95%E6%8D%89.png" alt="动作捕捉"></p>
<p>动作捕捉的数据采集有不同的方法，一种是光学动捕，在动捕演员的关键位置设置信号源，还有诸如应用了电磁波的或是直接纯机械的动捕，都可以达到最终目的</p>
<p>但是，动作捕捉在采集真实信息的时候也有一些技术难点，比如遮挡、环境影响等，这会导致采集的信息良莠不齐</p>
<p>另外该项技术对硬件的要求比较高，操作也非常复杂，是一个高成本动画制作方案</p>
<h4 id="动画制作流程"><a href="#动画制作流程" class="headerlink" title="动画制作流程"></a>动画制作流程</h4><p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="动画制作流程"></p>
<h3 id="模拟方法"><a href="#模拟方法" class="headerlink" title="模拟方法"></a>模拟方法</h3><h4 id="单粒子模拟"><a href="#单粒子模拟" class="headerlink" title="单粒子模拟"></a>单粒子模拟</h4><p>为了模拟一个粒子的运动，我们需要获取其任意时间的位置信息</p>
<p>为了达到这个目的，我们可以假定一个速度场，在场内使用一阶常微分方程来得到其速度信息</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E5%8D%95%E7%B2%92%E5%AD%90%E6%A8%A1%E6%8B%9F.png" alt="单粒子模拟"></p>
<p>计算得到速度之后，再用欧拉方法等各种手段，解出位置信息，得到模拟结果</p>
<h5 id="欧拉方法"><a href="#欧拉方法" class="headerlink" title="欧拉方法"></a>欧拉方法</h5><p>即对时间进行离散化，以一定步长细分时间，并每次用前一帧的计算结果更新当前帧的位置信息（前项欧拉）<br>$$<br>前项欧拉:\ x^{t+\triangle t}&#x3D;x^t+\triangle t \dot{x}^t\<br>非前项欧拉:\ \dot{x}^{t+\triangle t}&#x3D;\dot{x}^t+\triangle t \ddot{x}^t<br>$$<br>不过，这么做容易造成很大的误差，并且稳定性也非常差，如图</p>
<p>一旦步长低于一定精度，这种模拟就显得非常粗糙</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95%E8%AF%AF%E5%B7%AE%E5%A4%A7.png" alt="欧拉方法误差大"></p>
<p>而在一些速度场中，产生的误差会被无限放大，出现正反馈现象</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%B7%AE.png" alt="欧拉方法稳定性差"></p>
<p>为了改善这种模拟方法的不足之处，可以采用其他模拟方法，如下面介绍的中点法，自适应步长方法，隐式欧拉方法，龙格库塔方法等</p>
<h5 id="中点法"><a href="#中点法" class="headerlink" title="中点法"></a>中点法</h5><p>中点法其实就是做了两次欧拉方法，第一次欧拉方法获得中点位置，在取中点位置的速度，再代入算一遍欧拉方法</p>
<table>
<thead>
<tr>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E4%B8%AD%E7%82%B9%E6%B3%951.png" alt="中点法1"></th>
<th><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E4%B8%AD%E7%82%B9%E6%B3%952.png" alt="中点法2"></th>
</tr>
</thead>
</table>
<p>最后的形式有点像泰勒的样子，就是多了一个二次项</p>
<p>理解的话，可以用初中物理的平均速度概念，自己推一遍加速度方程，$\dot{x}$是速度，$\ddot{x}$是加速度</p>
<h5 id="自适应步长方法"><a href="#自适应步长方法" class="headerlink" title="自适应步长方法"></a>自适应步长方法</h5><p>这种方法也是算两遍欧拉，第一遍用$\triangle t$算，第二遍用$\frac{\triangle t}{2}$算，算完之后检验两次计算结果，如果偏差较大，则步长减半重新计算</p>
<p>这与直接减小步长的最大差别就是，他可以根据计算结果判断哪里应该用小步长，哪里用大步长，这就是所谓的“自适应”</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E8%87%AA%E9%80%82%E5%BA%94%E6%AD%A5%E9%95%BF%E6%B3%95.png" alt="自适应步长法"></p>
<h5 id="隐式欧拉方法"><a href="#隐式欧拉方法" class="headerlink" title="隐式欧拉方法"></a>隐式欧拉方法</h5><p>又称后向欧拉方法，前向欧拉是每次计算都用前一帧数据，那后向计算顾名思义就是用未来的数据</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E9%9A%90%E5%BC%8F%E7%9A%84%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95.png" alt="隐式的欧拉方法"></p>
<p>这种方法需要求解非线性方程组，会用到牛顿法等求根算法，计算会慢，但稳定性相应也高</p>
<p>如何定义稳定性：</p>
<p>考虑截断误差和总体误差，我们习惯用$O(h)$表示当步长减小为原来的一半，误差会相应减少为原来一半，用$O(h^2)$表示当步长减小为原来的一半，误差会相应减少为原来$\frac{1}4$……（h为步长）</p>
<p>对于隐式欧拉方法来说，它是一阶稳定的，截断误差满足$O(h^2)$，总体误差满足$O(h)$</p>
<h5 id="Runge-Kutta-Family"><a href="#Runge-Kutta-Family" class="headerlink" title="Runge-Kutta Family"></a>Runge-Kutta Family</h5><p>是一种四阶的方法，稳定性非常好</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E9%BE%99%E6%A0%BC%E5%BA%93%E5%A1%94.png" alt="龙格库塔"></p>
<p>公式推导会涉及很多数值分析的内容，还没学到，先放一放</p>
<h5 id="非物理方法"><a href="#非物理方法" class="headerlink" title="非物理方法"></a>非物理方法</h5><p>如位置调整法，韦尔莱积分等，这些方法通过调整粒子的位置使其满足一些特定性质，虽然不太物理（不满足能量守恒）也不太稳定，但实现起来比较简单，计算也比较快</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E9%9D%9E%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95.png" alt="非物理方法"></p>
<h4 id="刚体模拟"><a href="#刚体模拟" class="headerlink" title="刚体模拟"></a>刚体模拟</h4><p>主要思想是刚体不会发生形变，并且内部所有粒子都以同一种运动方式运动</p>
<p>那么相对于粒子模拟只考虑位置和速度，刚体模拟会考虑更多的参数，如角度和角速度，角速度和角加速度等这些的对应关系</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E5%88%9A%E4%BD%93%E6%A8%A1%E6%8B%9F.png" alt="刚体模拟"></p>
<h4 id="流体模拟"><a href="#流体模拟" class="headerlink" title="流体模拟"></a>流体模拟</h4><p>流体模拟算是一种典型的非物理方法粒子模拟</p>
<p>与刚体模拟一样，流体模拟同样认为流体粒子不可压缩，且密度处处相等（变化前后密度也保持不变），那么任何时刻，任意位置的流体粒子发生运动都会导致其周围粒子的密度发生变化（马尔科夫链），而要使运动前后密度不变，就需要通过改变流体粒子位置来修正</p>
<p>这个修正过程，就是流体模拟的过程</p>
<p>修正方法用到了深度学习的梯度下降法</p>
<p>注意，流体模拟的过程会有永动的情况出现，这时候可以人为加入外力消耗能量，使其最后稳定下来</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F1.png" alt="流体模拟1"></p>
<h4 id="模拟思想总结"><a href="#模拟思想总结" class="headerlink" title="模拟思想总结"></a>模拟思想总结</h4><p>有两种主流的模拟思想，拉格朗日视角（质点法）和欧拉视角（网格法），前一种是逐个进行单粒子模拟，后一种是将空间定义为多个网格单元，通过观察网格来决定如何模拟，关于这两种方法会在GAMES201物理引擎实战中有详细讲解</p>
<p>将上述两种思想结合，就是现在流行的材质点方法（MPM）</p>
<p>具体做法是，先将属性参数储存在粒子上（拉格朗日视角），再在模拟变换的过程中运用欧拉视角进行模拟计算，最后将每一个时刻网格的信息写回网格内的粒子上，并渲染到屏幕上</p>
<p><img src="F:/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/MPM.png" alt="MPM"></p>
<p>【END】</p>
</div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/bocchi.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Yui Lu</div><div class="author-info__description">Ciallo～(∠・ω< )⌒☆</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://www.zhihu.com/people/zhang-jia-hui-55-74"><i class="fab fa-zhihu"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/YuiLu" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="tencent://message/?Menu=yes&amp;uin=2903077287" target="_blank" title="'#24292e'"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:b2903077287@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/23208863?spm_id_from=333.1007.0.0" target="_blank" title="bilibili"><i class="fab fa-bilibili" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/63534/" title="test"><img src="https://api.aqcoder.cn/random" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="test"/></a><div class="content"><a class="title" href="/posts/63534/" title="test">test</a><time datetime="2024-01-15T02:22:46.000Z" title="发表于 2024-01-15 10:22:46">2024-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/16107/" title="Hello World"><img src="https://api.aqcoder.cn/random" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/posts/16107/" title="Hello World">Hello World</a><time datetime="2024-01-02T13:57:56.345Z" title="发表于 2024-01-02 21:57:56">2024-01-02</time></div></div></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><span class="card-archive-list-count">2</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">2</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-01-15T02:26:35.083Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Yui Lu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="128,128,128" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="{&quot;site_uv&quot;:true,&quot;site_pv&quot;:true,&quot;page_pv&quot;:true}"></script></div></body></html>